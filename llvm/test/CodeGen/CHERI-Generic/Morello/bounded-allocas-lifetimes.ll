; NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
; DO NOT EDIT -- This file was generated from test/CodeGen/CHERI-Generic/Inputs/bounded-allocas-lifetimes.ll
; CHERI-GENERIC-UTC: mir
; RUN: llc -mtriple=aarch64 --relocation-model=pic -target-abi purecap -mattr=+morello,+c64 %s -o - --stop-after=finalize-isel | FileCheck %s

; Check that lifetime markers don't get lost due to CheriBoundAllocas, as we'd
; risk StackSlotColoring reusing the slot.

declare void @use(i8 addrspace(200)*)

define void @static_alloca() {
  ; CHECK-LABEL: name: static_alloca
  ; CHECK: bb.0 (%ir-block.0):
  ; CHECK-NEXT:   [[CapAddImm:%[0-9]+]]:capsp = CapAddImm %stack.0, 0, 0
  ; CHECK-NEXT:   [[CapSetBoundsImm:%[0-9]+]]:capsp = CapSetBoundsImm killed [[CapAddImm]], 4, 0
  ; CHECK-NEXT:   LIFETIME_START %stack.0
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 0, 0, implicit-def dead $sp, implicit $sp
  ; CHECK-NEXT:   $c0 = COPY [[CapSetBoundsImm]]
  ; CHECK-NEXT:   BL @use, csr_aarch64_aapcs_32cap_regs, implicit-def dead $lr, implicit $sp, implicit $c0, implicit-def $sp
  ; CHECK-NEXT:   ADJCALLSTACKUP 0, 0, implicit-def dead $sp, implicit $sp
  ; CHECK-NEXT:   LIFETIME_END %stack.0
  ; CHECK-NEXT:   CRET_ReallyLR
  %1 = alloca i32, align 4, addrspace(200)
  %2 = bitcast i32 addrspace(200)* %1 to i8 addrspace(200)*
  call void @llvm.lifetime.start.p200i8(i64 4, i8 addrspace(200)* %2)
  call void @use(i8 addrspace(200)* %2)
  call void @llvm.lifetime.end.p200i8(i64 4, i8 addrspace(200)* %2)
  ret void
}

; LIFETIME_START/LIFETIME_END only apply to static allocas, so we can't verify
; that the analysis works correctly, but the IR is here for completeness.
define void @dynamic_alloca(i64 zeroext %n) {
  ; CHECK-LABEL: name: dynamic_alloca
  ; CHECK: bb.0 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $x0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:gpr64 = COPY $x0
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 0, 0, implicit-def dead $sp, implicit $sp
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:capsp = COPY $csp
  ; CHECK-NEXT:   [[CapGetValue:%[0-9]+]]:gpr64 = CapGetValue [[COPY1]]
  ; CHECK-NEXT:   [[UBFMXri:%[0-9]+]]:gpr64common = UBFMXri [[COPY]], 62, 61
  ; CHECK-NEXT:   [[ADDXri:%[0-9]+]]:gpr64common = nuw ADDXri [[UBFMXri]], 15, 0
  ; CHECK-NEXT:   [[ANDXri:%[0-9]+]]:gpr64common = ANDXri killed [[ADDXri]], 7995
  ; CHECK-NEXT:   [[CapRoundRepresentableLength:%[0-9]+]]:gpr64 = CapRoundRepresentableLength [[ANDXri]]
  ; CHECK-NEXT:   [[SUBSXrr:%[0-9]+]]:gpr64 = SUBSXrr killed [[CapGetValue]], [[CapRoundRepresentableLength]], implicit-def dead $nzcv
  ; CHECK-NEXT:   [[CapRoundRepresentableMask:%[0-9]+]]:gpr64 = CapRoundRepresentableMask [[ANDXri]]
  ; CHECK-NEXT:   [[ANDXrr:%[0-9]+]]:gpr64 = ANDXrr killed [[SUBSXrr]], killed [[CapRoundRepresentableMask]]
  ; CHECK-NEXT:   [[CapSetValue:%[0-9]+]]:capsp = CapSetValue [[COPY1]], killed [[ANDXrr]]
  ; CHECK-NEXT:   [[CapSetBounds:%[0-9]+]]:capsp = CapSetBounds [[CapSetValue]], [[CapRoundRepresentableLength]]
  ; CHECK-NEXT:   $csp = COPY [[CapSetValue]]
  ; CHECK-NEXT:   ADJCALLSTACKUP 0, 0, implicit-def dead $sp, implicit $sp
  ; CHECK-NEXT:   [[CapSetBounds1:%[0-9]+]]:capsp = CapSetBounds killed [[CapSetBounds]], [[UBFMXri]]
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 0, 0, implicit-def dead $sp, implicit $sp
  ; CHECK-NEXT:   $c0 = COPY [[CapSetBounds1]]
  ; CHECK-NEXT:   BL @use, csr_aarch64_aapcs_32cap_regs, implicit-def dead $lr, implicit $sp, implicit $c0, implicit-def $sp
  ; CHECK-NEXT:   ADJCALLSTACKUP 0, 0, implicit-def dead $sp, implicit $sp
  ; CHECK-NEXT:   CRET_ReallyLR
  %1 = alloca i32, i64 %n, align 4, addrspace(200)
  %2 = bitcast i32 addrspace(200)* %1 to i8 addrspace(200)*
  call void @llvm.lifetime.start.p200i8(i64 -1, i8 addrspace(200)* %2)
  call void @use(i8 addrspace(200)* %2)
  call void @llvm.lifetime.end.p200i8(i64 -1, i8 addrspace(200)* %2)
  ret void
}

declare void @llvm.lifetime.start.p200i8(i64, i8 addrspace(200)*)
declare void @llvm.lifetime.end.p200i8(i64, i8 addrspace(200)*)
