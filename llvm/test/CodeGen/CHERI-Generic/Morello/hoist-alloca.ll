; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --function-signature --scrub-attributes --force-update
; DO NOT EDIT -- This file was generated from test/CodeGen/CHERI-Generic/Inputs/hoist-alloca.ll
; REQUIRES: asserts
; Check that we can hoist the csetbounds for a local alloca outside of loops
; We know that it's always tagged and unsealed so machinelicm should be able to
; to hoist the csetbounds instructions.
; TODO: for MIPS "simple-register-coalescing" moves the CheriBoundedStackPseudoImm back into the loop.
; In general this will be faster than loading from the stack, but it's probably worse
; than using a callee-saved register for loops with many iterations.

; Generated from this code:
; void call(int *src, int *dst);
;
; void hoist_alloca_uncond(int cond) {
;   int buf1[123];
;   int buf2[22];
;   for (int i = 0; i < 100; i++) {
;     call(buf1, buf2);
;   }
; }
;
; void hoist_alloca_cond(int cond) {
;   int buf1[123];
;   int buf2[22];
;   for (int i = 0; i < 100; i++) {
;     if (cond) {
;       call(buf1, buf2);
;     }
;   }
; }

; RUN: llc -mtriple=aarch64 --relocation-model=pic -target-abi purecap -mattr=+morello,+c64 -o %t.mir -stop-before=early-machinelicm < %s
; RUN: llc -mtriple=aarch64 --relocation-model=pic -target-abi purecap -mattr=+morello,+c64 -run-pass=early-machinelicm -debug-only=machinelicm %t.mir -o /dev/null 2>%t.dbg
; RUN: FileCheck --input-file=%t.dbg --check-prefix=MACHINELICM-DBG %s
; Check that MachineLICM hoists the CheriBoundedStackPseudoImm (MIPS) / IncOffset+SetBoundsImm (RISCV) instructions
; For Morello there is no setbounds inside the loop due to the different alloca bunding pass, so there is nothing to hoist here.
; MACHINELICM-DBG-LABEL: ******** Pre-regalloc Machine LICM: hoist_alloca_uncond
; MACHINELICM-DBG-NOT: Hoisting
; MACHINELICM-DBG-LABEL: ******** Pre-regalloc Machine LICM: hoist_alloca_cond
; MACHINELICM-DBG-NOT: Hoisting

; RUN: llc -mtriple=aarch64 --relocation-model=pic -target-abi purecap -mattr=+morello,+c64 -O1 -o - < %s | FileCheck %s

define void @hoist_alloca_uncond(i32 signext %cond) local_unnamed_addr addrspace(200) nounwind {
; CHECK-LABEL: hoist_alloca_uncond:
; CHECK:       .Lfunc_begin0:
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    str c29, [csp, #-80]! // 16-byte Folded Spill
; CHECK-NEXT:    stp c30, c21, [csp, #16] // 32-byte Folded Spill
; CHECK-NEXT:    stp c20, c19, [csp, #48] // 32-byte Folded Spill
; CHECK-NEXT:    sub csp, csp, #592 // =592
; CHECK-NEXT:    mov w8, #492
; CHECK-NEXT:    add c0, csp, #100 // =100
; CHECK-NEXT:    mov w9, #88
; CHECK-NEXT:    add c1, csp, #12 // =12
; CHECK-NEXT:    scbndse c19, c0, x8
; CHECK-NEXT:    scbndse c20, c1, x9
; CHECK-NEXT:    mov w21, #100
; CHECK-NEXT:  .LBB0_1: // %for.body
; CHECK-NEXT:    // =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    mov c0, c19
; CHECK-NEXT:    mov c1, c20
; CHECK-NEXT:    bl call
; CHECK-NEXT:    subs w21, w21, #1 // =1
; CHECK-NEXT:    b.ne .LBB0_1
; CHECK-NEXT:  // %bb.2: // %for.cond.cleanup
; CHECK-NEXT:    add csp, csp, #592 // =592
; CHECK-NEXT:    ldp c20, c19, [csp, #48] // 32-byte Folded Reload
; CHECK-NEXT:    ldp c30, c21, [csp, #16] // 32-byte Folded Reload
; CHECK-NEXT:    ldr c29, [csp], #80 // 16-byte Folded Reload
; CHECK-NEXT:    ret c30
entry:
  %buf1 = alloca [123 x i32], align 4, addrspace(200)
  %buf2 = alloca [22 x i32], align 4, addrspace(200)
  br label %for.body

for.cond.cleanup:
  ret void

for.body:
  %i.04 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %arraydecay = getelementptr inbounds [123 x i32], [123 x i32] addrspace(200)* %buf1, i64 0, i64 0
  %arraydecay1 = getelementptr inbounds [22 x i32], [22 x i32] addrspace(200)* %buf2, i64 0, i64 0
  call void @call(i32 addrspace(200)* nonnull %arraydecay, i32 addrspace(200)* nonnull %arraydecay1)
  %inc = add nuw nsw i32 %i.04, 1
  %exitcond.not = icmp eq i32 %inc, 100
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body
}

declare void @call(i32 addrspace(200)*, i32 addrspace(200)*) local_unnamed_addr addrspace(200) nounwind

define void @hoist_alloca_cond(i32 signext %cond) local_unnamed_addr addrspace(200) nounwind {
; CHECK-LABEL: hoist_alloca_cond:
; CHECK:       .Lfunc_begin1:
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    stp c29, c30, [csp, #-96]! // 32-byte Folded Spill
; CHECK-NEXT:    stp c22, c21, [csp, #32] // 32-byte Folded Spill
; CHECK-NEXT:    stp c20, c19, [csp, #64] // 32-byte Folded Spill
; CHECK-NEXT:    sub csp, csp, #592 // =592
; CHECK-NEXT:    mov w19, w0
; CHECK-NEXT:    mov w8, #492
; CHECK-NEXT:    add c0, csp, #100 // =100
; CHECK-NEXT:    mov w9, #88
; CHECK-NEXT:    add c1, csp, #12 // =12
; CHECK-NEXT:    scbndse c20, c0, x8
; CHECK-NEXT:    scbndse c21, c1, x9
; CHECK-NEXT:    mov w22, #100
; CHECK-NEXT:    b .LBB1_2
; CHECK-NEXT:  .LBB1_1: // %for.inc
; CHECK-NEXT:    // in Loop: Header=BB1_2 Depth=1
; CHECK-NEXT:    subs w22, w22, #1 // =1
; CHECK-NEXT:    b.eq .LBB1_4
; CHECK-NEXT:  .LBB1_2: // %for.body
; CHECK-NEXT:    // =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    cbz w19, .LBB1_1
; CHECK-NEXT:  // %bb.3: // %if.then
; CHECK-NEXT:    // in Loop: Header=BB1_2 Depth=1
; CHECK-NEXT:    mov c0, c20
; CHECK-NEXT:    mov c1, c21
; CHECK-NEXT:    bl call
; CHECK-NEXT:    b .LBB1_1
; CHECK-NEXT:  .LBB1_4: // %for.cond.cleanup
; CHECK-NEXT:    add csp, csp, #592 // =592
; CHECK-NEXT:    ldp c20, c19, [csp, #64] // 32-byte Folded Reload
; CHECK-NEXT:    ldp c22, c21, [csp, #32] // 32-byte Folded Reload
; CHECK-NEXT:    ldp c29, c30, [csp], #96 // 32-byte Folded Reload
; CHECK-NEXT:    ret c30
entry:
  %buf1 = alloca [123 x i32], align 4, addrspace(200)
  %buf2 = alloca [22 x i32], align 4, addrspace(200)
  %tobool.not = icmp eq i32 %cond, 0
  br label %for.body

for.cond.cleanup:
  ret void

for.body:
  %i.04 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  br i1 %tobool.not, label %for.inc, label %if.then

if.then:
  %arraydecay = getelementptr inbounds [123 x i32], [123 x i32] addrspace(200)* %buf1, i64 0, i64 0
  %arraydecay1 = getelementptr inbounds [22 x i32], [22 x i32] addrspace(200)* %buf2, i64 0, i64 0
  call void @call(i32 addrspace(200)* nonnull %arraydecay, i32 addrspace(200)* nonnull %arraydecay1)
  br label %for.inc

for.inc:
  %inc = add nuw nsw i32 %i.04, 1
  %exitcond.not = icmp eq i32 %inc, 100
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body
}
