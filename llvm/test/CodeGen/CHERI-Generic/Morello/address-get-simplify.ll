; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --function-signature --scrub-attributes --force-update
; DO NOT EDIT -- This file was generated from test/CodeGen/CHERI-Generic/Inputs/address-get-simplify.ll
; RUN: opt < %s -mtriple=aarch64 --relocation-model=pic -target-abi aapcs -mattr=+morello,-c64 -instsimplify -S | FileCheck %s
; RUN: opt < %s -mtriple=aarch64 --relocation-model=pic -target-abi purecap -mattr=+morello,+c64 -instsimplify -S | FileCheck %s

; Derived from various existing ptrtoint tests.

declare i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)*)

define i1 @or_cmps_ptr_eq_zero_with_mask_commute1(i64 addrspace(200)* %p, i64 %y) {
; CHECK-LABEL: define {{[^@]+}}@or_cmps_ptr_eq_zero_with_mask_commute1
; CHECK-SAME: (i64 addrspace(200)* [[P:%.*]], i64 [[Y:%.*]]) #[[ATTR1:[0-9]+]] {
; CHECK-NEXT:    [[P1:%.*]] = bitcast i64 addrspace(200)* [[P]] to i8 addrspace(200)*
; CHECK-NEXT:    [[X:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* [[P1]])
; CHECK-NEXT:    [[SOMEBITS:%.*]] = and i64 [[X]], [[Y]]
; CHECK-NEXT:    [[SOMEBITS_ARE_ZERO:%.*]] = icmp eq i64 [[SOMEBITS]], 0
; CHECK-NEXT:    ret i1 [[SOMEBITS_ARE_ZERO]]
;
  %isnull = icmp eq i64 addrspace(200)* %p, null
  %p1 = bitcast i64 addrspace(200)* %p to i8 addrspace(200)*
  %x = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* %p1)
  %somebits = and i64 %x, %y
  %somebits_are_zero = icmp eq i64 %somebits, 0
  %r = or i1 %somebits_are_zero, %isnull
  ret i1 %r
}

define i1 @or_cmps_ptr_eq_zero_with_mask_commute3(i4 addrspace(200)* %p, i4 %y) {
; CHECK-LABEL: define {{[^@]+}}@or_cmps_ptr_eq_zero_with_mask_commute3
; CHECK-SAME: (i4 addrspace(200)* [[P:%.*]], i4 [[Y:%.*]]) #[[ATTR1]] {
; CHECK-NEXT:    [[P1:%.*]] = bitcast i4 addrspace(200)* [[P]] to i8 addrspace(200)*
; CHECK-NEXT:    [[XADDR:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* [[P1]])
; CHECK-NEXT:    [[X:%.*]] = trunc i64 [[XADDR]] to i4
; CHECK-NEXT:    [[SOMEBITS:%.*]] = and i4 [[Y]], [[X]]
; CHECK-NEXT:    [[SOMEBITS_ARE_ZERO:%.*]] = icmp eq i4 [[SOMEBITS]], 0
; CHECK-NEXT:    ret i1 [[SOMEBITS_ARE_ZERO]]
;
  %isnull = icmp eq i4 addrspace(200)* %p, null
  %p1 = bitcast i4 addrspace(200)* %p to i8 addrspace(200)*
  %xaddr = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* %p1)
  %x = trunc i64 %xaddr to i4
  %somebits = and i4 %y, %x
  %somebits_are_zero = icmp eq i4 %somebits, 0
  %r = or i1 %somebits_are_zero, %isnull
  ret i1 %r
}

define i1 @and_cmps_ptr_eq_zero_with_mask_commute2(i4 addrspace(200)* %p, i4 %y) {
; CHECK-LABEL: define {{[^@]+}}@and_cmps_ptr_eq_zero_with_mask_commute2
; CHECK-SAME: (i4 addrspace(200)* [[P:%.*]], i4 [[Y:%.*]]) #[[ATTR1]] {
; CHECK-NEXT:    [[P1:%.*]] = bitcast i4 addrspace(200)* [[P]] to i8 addrspace(200)*
; CHECK-NEXT:    [[XADDR:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* [[P1]])
; CHECK-NEXT:    [[X:%.*]] = trunc i64 [[XADDR]] to i4
; CHECK-NEXT:    [[SOMEBITS:%.*]] = and i4 [[X]], [[Y]]
; CHECK-NEXT:    [[SOMEBITS_ARE_NOT_ZERO:%.*]] = icmp ne i4 [[SOMEBITS]], 0
; CHECK-NEXT:    ret i1 [[SOMEBITS_ARE_NOT_ZERO]]
;
  %isnotnull = icmp ne i4 addrspace(200)* %p, null
  %p1 = bitcast i4 addrspace(200)* %p to i8 addrspace(200)*
  %xaddr = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* %p1)
  %x = trunc i64 %xaddr to i4
  %somebits = and i4 %x, %y
  %somebits_are_not_zero = icmp ne i4 %somebits, 0
  %r = and i1 %isnotnull, %somebits_are_not_zero
  ret i1 %r
}

define i1 @and_cmps_ptr_eq_zero_with_mask_commute4(i64 addrspace(200)* %p, i64 %y) {
; CHECK-LABEL: define {{[^@]+}}@and_cmps_ptr_eq_zero_with_mask_commute4
; CHECK-SAME: (i64 addrspace(200)* [[P:%.*]], i64 [[Y:%.*]]) #[[ATTR1]] {
; CHECK-NEXT:    [[P1:%.*]] = bitcast i64 addrspace(200)* [[P]] to i8 addrspace(200)*
; CHECK-NEXT:    [[X:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* [[P1]])
; CHECK-NEXT:    [[SOMEBITS:%.*]] = and i64 [[Y]], [[X]]
; CHECK-NEXT:    [[SOMEBITS_ARE_NOT_ZERO:%.*]] = icmp ne i64 [[SOMEBITS]], 0
; CHECK-NEXT:    ret i1 [[SOMEBITS_ARE_NOT_ZERO]]
;
  %isnotnull = icmp ne i64 addrspace(200)* %p, null
  %p1 = bitcast i64 addrspace(200)* %p to i8 addrspace(200)*
  %x = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* %p1)
  %somebits = and i64 %y, %x
  %somebits_are_not_zero = icmp ne i64 %somebits, 0
  %r = and i1 %isnotnull, %somebits_are_not_zero
  ret i1 %r
}

define i8 addrspace(200)* @D98611_1(i8 addrspace(200)* %c1, i64 %offset) {
; CHECK-LABEL: define {{[^@]+}}@D98611_1
; CHECK-SAME: (i8 addrspace(200)* [[C1:%.*]], i64 [[OFFSET:%.*]]) #[[ATTR1]] {
; CHECK-NEXT:    [[C2:%.*]] = getelementptr inbounds i8, i8 addrspace(200)* [[C1]], i64 [[OFFSET]]
; CHECK-NEXT:    ret i8 addrspace(200)* [[C2]]
;
  %c2 = getelementptr inbounds i8, i8 addrspace(200)* %c1, i64 %offset
  %ptrtoint1 = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* %c1)
  %ptrtoint2 = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* %c2)
  %sub = sub i64 %ptrtoint2, %ptrtoint1
  %gep = getelementptr inbounds i8, i8 addrspace(200)* %c1, i64 %sub
  ret i8 addrspace(200)* %gep
}

%struct.A = type { [7 x i8] }

define %struct.A addrspace(200)* @D98611_2(%struct.A addrspace(200)* %c1, i64 %offset) {
; CHECK-LABEL: define {{[^@]+}}@D98611_2
; CHECK-SAME: ([[STRUCT_A:%.*]] addrspace(200)* [[C1:%.*]], i64 [[OFFSET:%.*]]) #[[ATTR1]] {
; CHECK-NEXT:    [[C2:%.*]] = getelementptr inbounds [[STRUCT_A]], [[STRUCT_A]] addrspace(200)* [[C1]], i64 [[OFFSET]]
; CHECK-NEXT:    ret [[STRUCT_A]] addrspace(200)* [[C2]]
;
  %c2 = getelementptr inbounds %struct.A, %struct.A addrspace(200)* %c1, i64 %offset
  %p1 = bitcast %struct.A addrspace(200)* %c1 to i8 addrspace(200)*
  %p2 = bitcast %struct.A addrspace(200)* %c2 to i8 addrspace(200)*
  %ptrtoint1 = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* %p1)
  %ptrtoint2 = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* %p2)
  %sub = sub i64 %ptrtoint2, %ptrtoint1
  %sdiv = sdiv exact i64 %sub, 7
  %gep = getelementptr inbounds %struct.A, %struct.A addrspace(200)* %c1, i64 %sdiv
  ret %struct.A addrspace(200)* %gep
}

define i32 addrspace(200)* @D98611_3(i32 addrspace(200)* %c1, i64 %offset) {
; CHECK-LABEL: define {{[^@]+}}@D98611_3
; CHECK-SAME: (i32 addrspace(200)* [[C1:%.*]], i64 [[OFFSET:%.*]]) #[[ATTR1]] {
; CHECK-NEXT:    [[C2:%.*]] = getelementptr inbounds i32, i32 addrspace(200)* [[C1]], i64 [[OFFSET]]
; CHECK-NEXT:    ret i32 addrspace(200)* [[C2]]
;
  %c2 = getelementptr inbounds i32, i32 addrspace(200)* %c1, i64 %offset
  %p1 = bitcast i32 addrspace(200)* %c1 to i8 addrspace(200)*
  %p2 = bitcast i32 addrspace(200)* %c2 to i8 addrspace(200)*
  %ptrtoint1 = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* %p1)
  %ptrtoint2 = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* %p2)
  %sub = sub i64 %ptrtoint2, %ptrtoint1
  %ashr = ashr exact i64 %sub, 2
  %gep = getelementptr inbounds i32, i32 addrspace(200)* %c1, i64 %ashr
  ret i32 addrspace(200)* %gep
}
