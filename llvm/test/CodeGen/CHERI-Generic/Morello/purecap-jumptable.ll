; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --function-signature --scrub-attributes --force-update
; DO NOT EDIT -- This file was generated from test/CodeGen/CHERI-Generic/Inputs/purecap-jumptable.ll
; RUN: llc -mtriple=aarch64 --relocation-model=pic -target-abi purecap -mattr=+morello,+c64 < %s -o - | FileCheck %s
; Check that we can generate jump tables for switch statements.
; TODO: this is currently not implemented for CHERI-RISC-V

define void @below_threshold(i32 %in, i32 addrspace(200)* %out) nounwind {
; CHECK-LABEL: below_threshold:
; CHECK:       .Lfunc_begin0:
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    cmp w0, #1 // =1
; CHECK-NEXT:    b.eq .LBB0_3
; CHECK-NEXT:  // %bb.1: // %entry
; CHECK-NEXT:    cmp w0, #2 // =2
; CHECK-NEXT:    b.ne .LBB0_5
; CHECK-NEXT:  // %bb.2: // %bb2
; CHECK-NEXT:    mov w8, #3
; CHECK-NEXT:    b .LBB0_4
; CHECK-NEXT:  .LBB0_3:
; CHECK-NEXT:    mov w8, #4
; CHECK-NEXT:  .LBB0_4: // %exit.sink.split
; CHECK-NEXT:    str w8, [c1]
; CHECK-NEXT:  .LBB0_5: // %exit
; CHECK-NEXT:    ret c30
entry:
  switch i32 %in, label %exit [
  i32 1, label %bb1
  i32 2, label %bb2
  ]
bb1:
  store i32 4, i32 addrspace(200)* %out
  br label %exit
bb2:
  store i32 3, i32 addrspace(200)* %out
  br label %exit
exit:
  ret void
}

; For RISC-V the jump table threshold is set to 5 cases, but MIPS uses the default
; value of 4 (set in llvm/lib/CodeGen/TargetLoweringBase.cpp).
define void @above_threshold_mips(i32 %in, i32 addrspace(200)* %out) nounwind {
; CHECK-LABEL: above_threshold_mips:
; CHECK:       .Lfunc_begin1:
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    sub w8, w0, #1 // =1
; CHECK-NEXT:    cmp w8, #3 // =3
; CHECK-NEXT:    b.hi .LBB1_6
; CHECK-NEXT:  // %bb.1: // %entry
; CHECK-NEXT:    adrp c0, .LJTI1_0
; CHECK-NEXT:    add c0, c0, :lo12:.LJTI1_0
; CHECK-NEXT:    adr c2, .LBB1_2
; CHECK-NEXT:    ldrb w9, [c0, x8]
; CHECK-NEXT:    add c2, c2, x9, uxtx #2
; CHECK-NEXT:    cvtp x9, c2
; CHECK-NEXT:    mov w8, #4
; CHECK-NEXT:    br x9
; CHECK-NEXT:  .LBB1_2: // %bb2
; CHECK-NEXT:    mov w8, #3
; CHECK-NEXT:    b .LBB1_5
; CHECK-NEXT:  .LBB1_3: // %bb3
; CHECK-NEXT:    mov w8, #2
; CHECK-NEXT:    b .LBB1_5
; CHECK-NEXT:  .LBB1_4: // %bb4
; CHECK-NEXT:    mov w8, #1
; CHECK-NEXT:  .LBB1_5: // %exit.sink.split
; CHECK-NEXT:    str w8, [c1]
; CHECK-NEXT:  .LBB1_6: // %exit
; CHECK-NEXT:    ret c30
entry:
  switch i32 %in, label %exit [
  i32 1, label %bb1
  i32 2, label %bb2
  i32 3, label %bb3
  i32 4, label %bb4
  ]
bb1:
  store i32 4, i32 addrspace(200)* %out
  br label %exit
bb2:
  store i32 3, i32 addrspace(200)* %out
  br label %exit
bb3:
  store i32 2, i32 addrspace(200)* %out
  br label %exit
bb4:
  store i32 1, i32 addrspace(200)* %out
  br label %exit
exit:
  ret void
}

define void @above_threshold_all(i32 %in, i32 addrspace(200)* %out) nounwind {
; CHECK-LABEL: above_threshold_all:
; CHECK:       .Lfunc_begin2:
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    sub w8, w0, #1 // =1
; CHECK-NEXT:    cmp w8, #5 // =5
; CHECK-NEXT:    b.hi .LBB2_8
; CHECK-NEXT:  // %bb.1: // %entry
; CHECK-NEXT:    adrp c0, .LJTI2_0
; CHECK-NEXT:    add c0, c0, :lo12:.LJTI2_0
; CHECK-NEXT:    adr c2, .LBB2_2
; CHECK-NEXT:    ldrb w9, [c0, x8]
; CHECK-NEXT:    add c2, c2, x9, uxtx #2
; CHECK-NEXT:    cvtp x9, c2
; CHECK-NEXT:    mov w8, #4
; CHECK-NEXT:    br x9
; CHECK-NEXT:  .LBB2_2: // %bb2
; CHECK-NEXT:    mov w8, #3
; CHECK-NEXT:    b .LBB2_7
; CHECK-NEXT:  .LBB2_3: // %bb3
; CHECK-NEXT:    mov w8, #2
; CHECK-NEXT:    b .LBB2_7
; CHECK-NEXT:  .LBB2_4: // %bb4
; CHECK-NEXT:    mov w8, #1
; CHECK-NEXT:    b .LBB2_7
; CHECK-NEXT:  .LBB2_5: // %bb5
; CHECK-NEXT:    mov w8, #100
; CHECK-NEXT:    b .LBB2_7
; CHECK-NEXT:  .LBB2_6: // %bb6
; CHECK-NEXT:    mov w8, #200
; CHECK-NEXT:  .LBB2_7: // %exit.sink.split
; CHECK-NEXT:    str w8, [c1]
; CHECK-NEXT:  .LBB2_8: // %exit
; CHECK-NEXT:    ret c30
entry:
  switch i32 %in, label %exit [
  i32 1, label %bb1
  i32 2, label %bb2
  i32 3, label %bb3
  i32 4, label %bb4
  i32 5, label %bb5
  i32 6, label %bb6
  ]
bb1:
  store i32 4, i32 addrspace(200)* %out
  br label %exit
bb2:
  store i32 3, i32 addrspace(200)* %out
  br label %exit
bb3:
  store i32 2, i32 addrspace(200)* %out
  br label %exit
bb4:
  store i32 1, i32 addrspace(200)* %out
  br label %exit
bb5:
  store i32 100, i32 addrspace(200)* %out
  br label %exit
bb6:
  store i32 200, i32 addrspace(200)* %out
  br label %exit
exit:
  ret void
}
