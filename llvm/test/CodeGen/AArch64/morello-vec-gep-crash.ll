; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: sed -e 's/addrspace(200)/addrspace(0)/g' -e 's/-A200-P200-G200//g' %s |  llc -mtriple=aarch64-none-elf -mattr=+morello,-c64 -target-abi aapcs  | FileCheck %s --check-prefix AARCH64
; RUN: llc -mtriple=aarch64-none-elf -mattr=+morello,+c64 -target-abi purecap -o - %s | FileCheck %s --check-prefix PURECAP

; This test used to trigger "Assertion `N2.getValueType().isInteger() && "Second PTRADD argument must be an integer type!"' failed."
; The problem happens when splitting the four-capability vector into two two-capability vectors if
; one of the pairs is undef since SelectionDAG::FoldConstantArithmetic assumed that both arguments
; have the same value type.

define <4 x i8 addrspace(200)*> @vec_gep_with_poison_offsets_first_pair(i8 addrspace(200)* %ptr) nounwind {
; AARCH64-LABEL: vec_gep_with_poison_offsets_first_pair:
; AARCH64:       // %bb.0: // %bb
; AARCH64-NEXT:    adrp x8, .LCPI0_0
; AARCH64-NEXT:    ldr q0, [x8, :lo12:.LCPI0_0]
; AARCH64-NEXT:    dup v1.2d, x0
; AARCH64-NEXT:    add v1.2d, v1.2d, v0.2d
; AARCH64-NEXT:    ret
;
; PURECAP-LABEL: vec_gep_with_poison_offsets_first_pair:
; PURECAP:       .Lfunc_begin0:
; PURECAP-NEXT:  // %bb.0: // %bb
; PURECAP-NEXT:    add c2, c0, #1 // =1
; PURECAP-NEXT:    add c3, c0, #2 // =2
; PURECAP-NEXT:    ret c30
bb:
  %gep = getelementptr i8, i8 addrspace(200)* %ptr, <4 x i64> <i64 poison, i64 poison, i64 1, i64 2>
  ret <4 x i8 addrspace(200)*> %gep
}

define <4 x i8 addrspace(200)*> @vec_gep_with_poison_offsets_second_pair(i8 addrspace(200)* %ptr) nounwind {
; AARCH64-LABEL: vec_gep_with_poison_offsets_second_pair:
; AARCH64:       // %bb.0: // %bb
; AARCH64-NEXT:    adrp x8, .LCPI1_0
; AARCH64-NEXT:    ldr q0, [x8, :lo12:.LCPI1_0]
; AARCH64-NEXT:    dup v1.2d, x0
; AARCH64-NEXT:    add v0.2d, v1.2d, v0.2d
; AARCH64-NEXT:    ret
;
; PURECAP-LABEL: vec_gep_with_poison_offsets_second_pair:
; PURECAP:       .Lfunc_begin1:
; PURECAP-NEXT:  // %bb.0: // %bb
; PURECAP-NEXT:    add c2, c0, #1 // =1
; PURECAP-NEXT:    add c1, c0, #2 // =2
; PURECAP-NEXT:    mov c0, c2
; PURECAP-NEXT:    ret c30
bb:
  %gep = getelementptr i8, i8 addrspace(200)* %ptr, <4 x i64> <i64 1, i64 2, i64 poison, i64 poison>
  ret <4 x i8 addrspace(200)*> %gep
}

define <4 x i8 addrspace(200)*> @vec_gep_with_poison_bases_first_pair(i8 addrspace(200)* %ptr) nounwind {
; AARCH64-LABEL: vec_gep_with_poison_bases_first_pair:
; AARCH64:       // %bb.0: // %bb
; AARCH64-NEXT:    mov w8, #123
; AARCH64-NEXT:    dup v1.2d, x8
; AARCH64-NEXT:    ret
;
; PURECAP-LABEL: vec_gep_with_poison_bases_first_pair:
; PURECAP:       .Lfunc_begin2:
; PURECAP-NEXT:  // %bb.0: // %bb
; PURECAP-NEXT:    mov x0, xzr
; PURECAP-NEXT:    add c2, c0, #123 // =123
; PURECAP-NEXT:    mov c3, c2
; PURECAP-NEXT:    ret c30
bb:
  %gep = getelementptr i8, <4 x i8 addrspace(200)*> <i8 addrspace(200)* poison, i8 addrspace(200)* poison, i8 addrspace(200)* null, i8 addrspace(200)* null>, i64 123
  ret <4 x i8 addrspace(200)*> %gep
}

define <4 x i8 addrspace(200)*> @vec_gep_with_null_base(i8 addrspace(200)* %ptr) nounwind {
; AARCH64-LABEL: vec_gep_with_null_base:
; AARCH64:       // %bb.0: // %bb
; AARCH64-NEXT:    mov w8, #123
; AARCH64-NEXT:    dup v0.2d, x8
; AARCH64-NEXT:    mov v1.16b, v0.16b
; AARCH64-NEXT:    ret
;
; PURECAP-LABEL: vec_gep_with_null_base:
; PURECAP:       .Lfunc_begin3:
; PURECAP-NEXT:  // %bb.0: // %bb
; PURECAP-NEXT:    mov x0, xzr
; PURECAP-NEXT:    add c0, c0, #123 // =123
; PURECAP-NEXT:    mov c1, c0
; PURECAP-NEXT:    mov c2, c0
; PURECAP-NEXT:    mov c3, c0
; PURECAP-NEXT:    ret c30
bb:
  %gep = getelementptr i8, <4 x i8 addrspace(200)*> <i8 addrspace(200)* null, i8 addrspace(200)* null, i8 addrspace(200)* null, i8 addrspace(200)* null>, i64 123
  ret <4 x i8 addrspace(200)*> %gep
}

define <4 x i8 addrspace(200)*> @vec_gep_with_vec_offsets(i8 addrspace(200)* %ptr) nounwind {
; AARCH64-LABEL: vec_gep_with_vec_offsets:
; AARCH64:       // %bb.0: // %bb
; AARCH64-NEXT:    adrp x8, .LCPI4_0
; AARCH64-NEXT:    ldr q1, [x8, :lo12:.LCPI4_0]
; AARCH64-NEXT:    adrp x8, .LCPI4_1
; AARCH64-NEXT:    ldr q0, [x8, :lo12:.LCPI4_1]
; AARCH64-NEXT:    dup v2.2d, x0
; AARCH64-NEXT:    add v1.2d, v2.2d, v1.2d
; AARCH64-NEXT:    ret
;
; PURECAP-LABEL: vec_gep_with_vec_offsets:
; PURECAP:       .Lfunc_begin4:
; PURECAP-NEXT:  // %bb.0: // %bb
; PURECAP-NEXT:    mov x1, xzr
; PURECAP-NEXT:    add c4, c1, #1 // =1
; PURECAP-NEXT:    add c1, c1, #2 // =2
; PURECAP-NEXT:    add c2, c0, #3 // =3
; PURECAP-NEXT:    add c3, c0, #4 // =4
; PURECAP-NEXT:    mov c0, c4
; PURECAP-NEXT:    ret c30
bb:
  %vec1 = insertelement <4 x i8 addrspace(200)*> <i8 addrspace(200)* null, i8 addrspace(200)* null, i8 addrspace(200)* null, i8 addrspace(200)* null>, i8 addrspace(200)* %ptr, i32 2
  %vec2 = insertelement <4 x i8 addrspace(200)*> %vec1, i8 addrspace(200)* %ptr, i32 3
  %gep = getelementptr i8, <4 x i8 addrspace(200)*> %vec2, <4 x i64> <i64 1, i64 2, i64 3, i64 4>
  ret <4 x i8 addrspace(200)*> %gep
}
