; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=arm64-linux-gnu -mattr=+c64,+morello -target-abi purecap -verify-machineinstrs | FileCheck %s

@var = addrspace(200) global i128 0

define i128 @val_compare_and_swap(i128 addrspace(200)* %p, i128 %oldval, i128 %newval) {
; CHECK-LABEL: val_compare_and_swap:
; CHECK:       .Lfunc_begin0:
; CHECK-NEXT:    .cfi_startproc purecap
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:  .LBB0_1: // =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    ldaxp x8, x1, [c0]
; CHECK-NEXT:    cmp x8, x2
; CHECK-NEXT:    cset w9, ne
; CHECK-NEXT:    cmp x1, x3
; CHECK-NEXT:    cinc w9, w9, ne
; CHECK-NEXT:    cbz w9, .LBB0_3
; CHECK-NEXT:  // %bb.2: // in Loop: Header=BB0_1 Depth=1
; CHECK-NEXT:    stxp w9, x8, x1, [c0]
; CHECK-NEXT:    cbnz w9, .LBB0_1
; CHECK-NEXT:    b .LBB0_4
; CHECK-NEXT:  .LBB0_3: // in Loop: Header=BB0_1 Depth=1
; CHECK-NEXT:    stxp w9, x4, x5, [c0]
; CHECK-NEXT:    cbnz w9, .LBB0_1
; CHECK-NEXT:  .LBB0_4:
; CHECK-NEXT:    mov x0, x8
; CHECK-NEXT:    ret c30
  %pair = cmpxchg i128 addrspace(200) * %p, i128 %oldval, i128 %newval acquire acquire
  %val = extractvalue { i128, i1 } %pair, 0
  ret i128 %val
}

define void @fetch_and_nand(i128 addrspace(200) * %p, i128 %bits) {
; CHECK-LABEL: fetch_and_nand:
; CHECK:       .Lfunc_begin1:
; CHECK-NEXT:    .cfi_startproc purecap
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:  .LBB1_1: // %atomicrmw.start
; CHECK-NEXT:    // =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    ldxp x9, x8, [c0]
; CHECK-NEXT:    and x10, x9, x2
; CHECK-NEXT:    and x11, x8, x3
; CHECK-NEXT:    mvn x11, x11
; CHECK-NEXT:    mvn x10, x10
; CHECK-NEXT:    stlxp w12, x10, x11, [c0]
; CHECK-NEXT:    cbnz w12, .LBB1_1
; CHECK-NEXT:  // %bb.2: // %atomicrmw.end
; CHECK-NEXT:    adrp c0, :got:var
; CHECK-NEXT:    ldr c0, [c0, :got_lo12:var]
; CHECK-NEXT:    stp x9, x8, [c0]
; CHECK-NEXT:    ret c30

  %val = atomicrmw nand i128 addrspace(200) * %p, i128 %bits release
  store i128 %val, i128 addrspace(200) * @var, align 16
  ret void
}

define void @fetch_and_or(i128 addrspace(200) * %p, i128 %bits) {
; CHECK-LABEL: fetch_and_or:
; CHECK:       .Lfunc_begin2:
; CHECK-NEXT:    .cfi_startproc purecap
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:  .LBB2_1: // %atomicrmw.start
; CHECK-NEXT:    // =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    ldaxp x9, x8, [c0]
; CHECK-NEXT:    orr x10, x8, x3
; CHECK-NEXT:    orr x11, x9, x2
; CHECK-NEXT:    stlxp w12, x11, x10, [c0]
; CHECK-NEXT:    cbnz w12, .LBB2_1
; CHECK-NEXT:  // %bb.2: // %atomicrmw.end
; CHECK-NEXT:    adrp c0, :got:var
; CHECK-NEXT:    ldr c0, [c0, :got_lo12:var]
; CHECK-NEXT:    stp x9, x8, [c0]
; CHECK-NEXT:    ret c30

  %val = atomicrmw or i128 addrspace(200) * %p, i128 %bits seq_cst
  store i128 %val, i128 addrspace(200) * @var, align 16
  ret void
}

define void @fetch_and_add(i128 addrspace(200) * %p, i128 %bits) {
; CHECK-LABEL: fetch_and_add:
; CHECK:       .Lfunc_begin3:
; CHECK-NEXT:    .cfi_startproc purecap
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:  .LBB3_1: // %atomicrmw.start
; CHECK-NEXT:    // =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    ldaxp x9, x8, [c0]
; CHECK-NEXT:    adds x10, x9, x2
; CHECK-NEXT:    adcs x11, x8, x3
; CHECK-NEXT:    stlxp w12, x10, x11, [c0]
; CHECK-NEXT:    cbnz w12, .LBB3_1
; CHECK-NEXT:  // %bb.2: // %atomicrmw.end
; CHECK-NEXT:    adrp c0, :got:var
; CHECK-NEXT:    ldr c0, [c0, :got_lo12:var]
; CHECK-NEXT:    stp x9, x8, [c0]
; CHECK-NEXT:    ret c30

  %val = atomicrmw add i128 addrspace(200) * %p, i128 %bits seq_cst
  store i128 %val, i128 addrspace(200) * @var, align 16
  ret void
}

define void @fetch_and_sub(i128 addrspace(200) * %p, i128 %bits) {
; CHECK-LABEL: fetch_and_sub:
; CHECK:       .Lfunc_begin4:
; CHECK-NEXT:    .cfi_startproc purecap
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:  .LBB4_1: // %atomicrmw.start
; CHECK-NEXT:    // =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    ldaxp x9, x8, [c0]
; CHECK-NEXT:    subs x10, x9, x2
; CHECK-NEXT:    sbcs x11, x8, x3
; CHECK-NEXT:    stlxp w12, x10, x11, [c0]
; CHECK-NEXT:    cbnz w12, .LBB4_1
; CHECK-NEXT:  // %bb.2: // %atomicrmw.end
; CHECK-NEXT:    adrp c0, :got:var
; CHECK-NEXT:    ldr c0, [c0, :got_lo12:var]
; CHECK-NEXT:    stp x9, x8, [c0]
; CHECK-NEXT:    ret c30

  %val = atomicrmw sub i128 addrspace(200) * %p, i128 %bits seq_cst
  store i128 %val, i128 addrspace(200) * @var, align 16
  ret void
}

define void @fetch_and_min(i128 addrspace(200) * %p, i128 %bits) {
; CHECK-LABEL: fetch_and_min:
; CHECK:       .Lfunc_begin5:
; CHECK-NEXT:    .cfi_startproc purecap
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:  .LBB5_1: // %atomicrmw.start
; CHECK-NEXT:    // =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    ldaxp x9, x8, [c0]
; CHECK-NEXT:    cmp x9, x2
; CHECK-NEXT:    cset w10, ls
; CHECK-NEXT:    cmp x8, x3
; CHECK-NEXT:    cset w11, le
; CHECK-NEXT:    csel w10, w10, w11, eq
; CHECK-NEXT:    cmp w10, #0 // =0
; CHECK-NEXT:    csel x10, x8, x3, ne
; CHECK-NEXT:    csel x11, x9, x2, ne
; CHECK-NEXT:    stlxp w12, x11, x10, [c0]
; CHECK-NEXT:    cbnz w12, .LBB5_1
; CHECK-NEXT:  // %bb.2: // %atomicrmw.end
; CHECK-NEXT:    adrp c0, :got:var
; CHECK-NEXT:    ldr c0, [c0, :got_lo12:var]
; CHECK-NEXT:    stp x9, x8, [c0]
; CHECK-NEXT:    ret c30

  %val = atomicrmw min i128 addrspace(200) * %p, i128 %bits seq_cst
  store i128 %val, i128 addrspace(200) * @var, align 16
  ret void
}

define void @fetch_and_max(i128 addrspace(200) * %p, i128 %bits) {
; CHECK-LABEL: fetch_and_max:
; CHECK:       .Lfunc_begin6:
; CHECK-NEXT:    .cfi_startproc purecap
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:  .LBB6_1: // %atomicrmw.start
; CHECK-NEXT:    // =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    ldaxp x9, x8, [c0]
; CHECK-NEXT:    cmp x9, x2
; CHECK-NEXT:    cset w10, hi
; CHECK-NEXT:    cmp x8, x3
; CHECK-NEXT:    cset w11, gt
; CHECK-NEXT:    csel w10, w10, w11, eq
; CHECK-NEXT:    cmp w10, #0 // =0
; CHECK-NEXT:    csel x10, x8, x3, ne
; CHECK-NEXT:    csel x11, x9, x2, ne
; CHECK-NEXT:    stlxp w12, x11, x10, [c0]
; CHECK-NEXT:    cbnz w12, .LBB6_1
; CHECK-NEXT:  // %bb.2: // %atomicrmw.end
; CHECK-NEXT:    adrp c0, :got:var
; CHECK-NEXT:    ldr c0, [c0, :got_lo12:var]
; CHECK-NEXT:    stp x9, x8, [c0]
; CHECK-NEXT:    ret c30

  %val = atomicrmw max i128 addrspace(200) * %p, i128 %bits seq_cst
  store i128 %val, i128 addrspace(200) * @var, align 16
  ret void
}

define void @fetch_and_umin(i128 addrspace(200) * %p, i128 %bits) {
; CHECK-LABEL: fetch_and_umin:
; CHECK:       .Lfunc_begin7:
; CHECK-NEXT:    .cfi_startproc purecap
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:  .LBB7_1: // %atomicrmw.start
; CHECK-NEXT:    // =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    ldaxp x9, x8, [c0]
; CHECK-NEXT:    cmp x9, x2
; CHECK-NEXT:    cset w10, ls
; CHECK-NEXT:    cmp x8, x3
; CHECK-NEXT:    cset w11, ls
; CHECK-NEXT:    csel w10, w10, w11, eq
; CHECK-NEXT:    cmp w10, #0 // =0
; CHECK-NEXT:    csel x10, x8, x3, ne
; CHECK-NEXT:    csel x11, x9, x2, ne
; CHECK-NEXT:    stlxp w12, x11, x10, [c0]
; CHECK-NEXT:    cbnz w12, .LBB7_1
; CHECK-NEXT:  // %bb.2: // %atomicrmw.end
; CHECK-NEXT:    adrp c0, :got:var
; CHECK-NEXT:    ldr c0, [c0, :got_lo12:var]
; CHECK-NEXT:    stp x9, x8, [c0]
; CHECK-NEXT:    ret c30

  %val = atomicrmw umin i128 addrspace(200) * %p, i128 %bits seq_cst
  store i128 %val, i128 addrspace(200) * @var, align 16
  ret void
}

define void @fetch_and_umax(i128 addrspace(200) * %p, i128 %bits) {
; CHECK-LABEL: fetch_and_umax:
; CHECK:       .Lfunc_begin8:
; CHECK-NEXT:    .cfi_startproc purecap
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:  .LBB8_1: // %atomicrmw.start
; CHECK-NEXT:    // =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    ldaxp x9, x8, [c0]
; CHECK-NEXT:    cmp x9, x2
; CHECK-NEXT:    cset w10, hi
; CHECK-NEXT:    cmp x8, x3
; CHECK-NEXT:    cset w11, hi
; CHECK-NEXT:    csel w10, w10, w11, eq
; CHECK-NEXT:    cmp w10, #0 // =0
; CHECK-NEXT:    csel x10, x8, x3, ne
; CHECK-NEXT:    csel x11, x9, x2, ne
; CHECK-NEXT:    stlxp w12, x11, x10, [c0]
; CHECK-NEXT:    cbnz w12, .LBB8_1
; CHECK-NEXT:  // %bb.2: // %atomicrmw.end
; CHECK-NEXT:    adrp c0, :got:var
; CHECK-NEXT:    ldr c0, [c0, :got_lo12:var]
; CHECK-NEXT:    stp x9, x8, [c0]
; CHECK-NEXT:    ret c30

  %val = atomicrmw umax i128 addrspace(200) * %p, i128 %bits seq_cst
  store i128 %val, i128 addrspace(200) * @var, align 16
  ret void
}

define i128 @atomic_load_seq_cst(i128 addrspace(200) * %p) {
; CHECK-LABEL: atomic_load_seq_cst:
; CHECK:       .Lfunc_begin9:
; CHECK-NEXT:    .cfi_startproc purecap
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    mov c2, c0
; CHECK-NEXT:  .LBB9_1: // %atomicrmw.start
; CHECK-NEXT:    // =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    ldaxp x0, x1, [c2]
; CHECK-NEXT:    stlxp w8, x0, x1, [c2]
; CHECK-NEXT:    cbnz w8, .LBB9_1
; CHECK-NEXT:  // %bb.2: // %atomicrmw.end
; CHECK-NEXT:    ret c30
   %r = load atomic i128, i128 addrspace(200) * %p seq_cst, align 16
   ret i128 %r
}

define i128 @atomic_load_relaxed(i64, i64, i128 addrspace(200) * %p) {
; CHECK-LABEL: atomic_load_relaxed:
; CHECK:       .Lfunc_begin10:
; CHECK-NEXT:    .cfi_startproc purecap
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:  .LBB10_1: // %atomicrmw.start
; CHECK-NEXT:    // =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    ldxp x0, x1, [c2]
; CHECK-NEXT:    stxp w8, x0, x1, [c2]
; CHECK-NEXT:    cbnz w8, .LBB10_1
; CHECK-NEXT:  // %bb.2: // %atomicrmw.end
; CHECK-NEXT:    ret c30
   %r = load atomic i128, i128 addrspace(200) * %p monotonic, align 16
   ret i128 %r
}

define void @atomic_store_seq_cst(i128 %in, i128 addrspace(200) * %p) {
; CHECK-LABEL: atomic_store_seq_cst:
; CHECK:       .Lfunc_begin11:
; CHECK-NEXT:    .cfi_startproc purecap
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:  .LBB11_1: // %atomicrmw.start
; CHECK-NEXT:    // =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    ldaxp xzr, x8, [c2]
; CHECK-NEXT:    stlxp w8, x0, x1, [c2]
; CHECK-NEXT:    cbnz w8, .LBB11_1
; CHECK-NEXT:  // %bb.2: // %atomicrmw.end
; CHECK-NEXT:    ret c30
   store atomic i128 %in, i128 addrspace(200) * %p seq_cst, align 16
   ret void
}

define void @atomic_store_release(i128 %in, i128 addrspace(200) * %p) {
; CHECK-LABEL: atomic_store_release:
; CHECK:       .Lfunc_begin12:
; CHECK-NEXT:    .cfi_startproc purecap
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:  .LBB12_1: // %atomicrmw.start
; CHECK-NEXT:    // =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    ldxp xzr, x8, [c2]
; CHECK-NEXT:    stlxp w8, x0, x1, [c2]
; CHECK-NEXT:    cbnz w8, .LBB12_1
; CHECK-NEXT:  // %bb.2: // %atomicrmw.end
; CHECK-NEXT:    ret c30
   store atomic i128 %in, i128 addrspace(200) * %p release, align 16
   ret void
}

define void @atomic_store_relaxed(i128 %in, i128 addrspace(200) * %p) {
; CHECK-LABEL: atomic_store_relaxed:
; CHECK:       .Lfunc_begin13:
; CHECK-NEXT:    .cfi_startproc purecap
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:  .LBB13_1: // %atomicrmw.start
; CHECK-NEXT:    // =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    ldxp xzr, x8, [c2]
; CHECK-NEXT:    stxp w8, x0, x1, [c2]
; CHECK-NEXT:    cbnz w8, .LBB13_1
; CHECK-NEXT:  // %bb.2: // %atomicrmw.end
; CHECK-NEXT:    ret c30
   store atomic i128 %in, i128 addrspace(200) * %p unordered, align 16
   ret void
}
