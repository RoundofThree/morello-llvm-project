; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -march=aarch64 -mattr=+morello,+c64 -target-abi purecap -disable-post-ra -o - %s -cheri-cap-table-abi=fn-desc --frame-pointer=none | FileCheck %s

target datalayout = "e-m:e-pf200:128:128:128:64-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128-A200-P200-G200"
target triple = "aarch64-none-unknown-elf"

@_ZTIi = external addrspace(200) constant i8 addrspace(200)*

; Since c28 needs to be restored in landing pads we need to save it even
; if we don't have non-local calls.

define noundef i32 @_Z3barv() local_unnamed_addr addrspace(200) personality i8 addrspace(200)* bitcast (i32 (...) addrspace(200)* @__gxx_personality_v0 to i8 addrspace(200)*) {
; CHECK-LABEL: _Z3barv:
; CHECK:       .L_Z3barv$eh_alias:
; CHECK-NEXT:  .Lfunc_begin0:
; CHECK-NEXT:    .cfi_startproc
; CHECK-NEXT:    .cfi_personality 0, __gxx_personality_v0
; CHECK-NEXT:    .cfi_lsda 0, .Lexception0
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    mov c28, c29
; CHECK-NEXT:    stp c30, c19, [csp, #-32]! // 32-byte Folded Spill
; CHECK-NEXT:    .cfi_def_cfa_offset 32
; CHECK-NEXT:    .cfi_offset c19, -16
; CHECK-NEXT:    .cfi_offset c30, -32
; CHECK-NEXT:    mov c19, c28
; CHECK-NEXT:  .Ltmp0:
; CHECK-NEXT:    bl _ZL3foov
; CHECK-NEXT:  .Ltmp1:
; CHECK-NEXT:  // %bb.1:
; CHECK-NEXT:    mov w0, wzr
; CHECK-NEXT:    ldp c30, c19, [csp], #32 // 32-byte Folded Reload
; CHECK-NEXT:    ret c30
; CHECK-NEXT:  .LBB0_2: // %lpad
; CHECK-NEXT:  .Ltmp2:
; CHECK-NEXT:    mov c28, c19
; CHECK-NEXT:    bl __cxa_begin_catch
; CHECK-NEXT:    mov c28, c19
; CHECK-NEXT:    bl __cxa_end_catch
; CHECK-NEXT:    mov c28, c19
; CHECK-NEXT:    mov w0, #42
; CHECK-NEXT:    ldp c30, c19, [csp], #32 // 32-byte Folded Reload
; CHECK-NEXT:    ret c30
entry:
  invoke fastcc void @_ZL3foov()
          to label %return unwind label %lpad

lpad:
  %0 = landingpad { i8 addrspace(200)*, i32 }
          catch i8 addrspace(200)* bitcast (i8 addrspace(200)* addrspace(200)* @_ZTIi to i8 addrspace(200)*)
  %1 = extractvalue { i8 addrspace(200)*, i32 } %0, 1
  %2 = tail call i32 @llvm.eh.typeid.for(i8* addrspacecast (i8 addrspace(200)* bitcast (i8 addrspace(200)* addrspace(200)* @_ZTIi to i8 addrspace(200)*) to i8*))
  %matches = icmp eq i32 %1, %2
  br i1 %matches, label %catch, label %eh.resume

catch:
  %3 = extractvalue { i8 addrspace(200)*, i32 } %0, 0
  %4 = tail call i8 addrspace(200)* @__cxa_begin_catch(i8 addrspace(200)* %3)
  tail call void @__cxa_end_catch()
  br label %return

return:
  %retval.0 = phi i32 [ 42, %catch ], [ 0, %entry ]
  ret i32 %retval.0

eh.resume:
  resume { i8 addrspace(200)*, i32 } %0
}

define internal fastcc void @_ZL3foov() unnamed_addr addrspace(200) {
; CHECK-LABEL: _ZL3foov:
; CHECK:       .Lfunc_begin1:
; CHECK-NEXT:    .cfi_startproc
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    mov c28, c29
; CHECK-NEXT:    stp c30, c19, [csp, #-32]! // 32-byte Folded Spill
; CHECK-NEXT:    .cfi_def_cfa_offset 32
; CHECK-NEXT:    .cfi_offset c19, -16
; CHECK-NEXT:    .cfi_offset c30, -32
; CHECK-NEXT:    mov c19, c28
; CHECK-NEXT:    mov w0, #4
; CHECK-NEXT:    bl __cxa_allocate_exception
; CHECK-NEXT:    mov c28, c19
; CHECK-NEXT:    mov w8, #20
; CHECK-NEXT:    str w8, [c0]
; CHECK-NEXT:    adrp c1, :got:_ZTIi
; CHECK-NEXT:    ldr c1, [c1, :got_lo12:_ZTIi]
; CHECK-NEXT:    mov x2, xzr
; CHECK-NEXT:    bl __cxa_throw
; CHECK-NEXT:    mov c28, c19
entry:
  %exception = tail call i8 addrspace(200)* @__cxa_allocate_exception(i64 4)
  %0 = bitcast i8 addrspace(200)* %exception to i32 addrspace(200)*
  store i32 20, i32 addrspace(200)* %0, align 16
  tail call void @__cxa_throw(i8 addrspace(200)* %exception, i8 addrspace(200)* bitcast (i8 addrspace(200)* addrspace(200)* @_ZTIi to i8 addrspace(200)*), i8 addrspace(200)* null)
  unreachable
}

declare i32 @__gxx_personality_v0(...) addrspace(200)

; Function Attrs: nofree nosync nounwind readnone
declare i32 @llvm.eh.typeid.for(i8*) addrspace(200)

declare i8 addrspace(200)* @__cxa_begin_catch(i8 addrspace(200)*) local_unnamed_addr addrspace(200)

declare void @__cxa_end_catch() local_unnamed_addr addrspace(200)

declare i8 addrspace(200)* @__cxa_allocate_exception(i64) local_unnamed_addr addrspace(200)

declare void @__cxa_throw(i8 addrspace(200)*, i8 addrspace(200)*, i8 addrspace(200)*) local_unnamed_addr addrspace(200)
