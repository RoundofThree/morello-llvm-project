; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=aarch64-none-elf -mattr=+c64,+morello -target-abi=purecap -aarch64-enable-global-merge | FileCheck %s

target datalayout = "e-m:e-pf200:128:128:128:64-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128-A200-P200-G200"
target triple = "aarch64-none-unknown-elf"

@x0 = internal addrspace(200) global i32 0, align 4
@x1 = internal addrspace(200) global [200 x i32] zeroinitializer, align 4
@x2 = internal addrspace(200) global [200 x i32] zeroinitializer, align 4

define i32 @getvals(i8 addrspace(200)* addrspace(200)* nocapture %a) local_unnamed_addr addrspace(200) {
; CHECK-LABEL: getvals:
; CHECK:       .Lfunc_begin0:
; CHECK-NEXT:    .cfi_startproc purecap
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    adrp c1, .L__cap_merged_table+16
; CHECK-NEXT:    ldr c1, [c1, :lo12:.L__cap_merged_table+16]
; CHECK-NEXT:    adrp c2, .L__cap_merged_table+32
; CHECK-NEXT:    ldr c2, [c2, :lo12:.L__cap_merged_table+32]
; CHECK-NEXT:    adrp c3, .L__cap_merged_table+48
; CHECK-NEXT:    ldr c3, [c3, :lo12:.L__cap_merged_table+48]
; CHECK-NEXT:    stp c1, c2, [c0, #0]
; CHECK-NEXT:    str c3, [c0, #32]
; CHECK-NEXT:    ret c30
entry:
  store i8 addrspace(200)* bitcast (i32 addrspace(200)* @x0 to i8 addrspace(200)*), i8 addrspace(200)* addrspace(200)* %a, align 16
  %arrayidx1 = getelementptr inbounds i8 addrspace(200)*, i8 addrspace(200)* addrspace(200)* %a, i64 1
  store i8 addrspace(200)* bitcast ([200 x i32] addrspace(200)* @x1 to i8 addrspace(200)*), i8 addrspace(200)* addrspace(200)* %arrayidx1, align 16
  %arrayidx2 = getelementptr inbounds i8 addrspace(200)*, i8 addrspace(200)* addrspace(200)* %a, i64 2
  store i8 addrspace(200)* bitcast ([200 x i32] addrspace(200)* @x2 to i8 addrspace(200)*), i8 addrspace(200)* addrspace(200)* %arrayidx2, align 16
  ret i32 undef
}

; Make sure LSR doesn't replace global aliases produced by global merge with the aliasee.
define void @foo(i32 %a) local_unnamed_addr addrspace(200) {
; CHECK-LABEL: foo:
; CHECK:       .Lfunc_begin1:
; CHECK-NEXT:    .cfi_startproc purecap
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    stp c30, c21, [csp, #-64]! // 32-byte Folded Spill
; CHECK-NEXT:    stp c20, c19, [csp, #32] // 32-byte Folded Spill
; CHECK-NEXT:    .cfi_def_cfa_offset 64
; CHECK-NEXT:    .cfi_offset c19, -16
; CHECK-NEXT:    .cfi_offset c20, -32
; CHECK-NEXT:    .cfi_offset c21, -48
; CHECK-NEXT:    .cfi_offset c30, -64
; CHECK-NEXT:    bl g
; CHECK-NEXT:    cmp w0, #1 // =1
; CHECK-NEXT:    b.lt .LBB1_3
; CHECK-NEXT:  // %bb.1: // %for.body.preheader
; CHECK-NEXT:    adrp c20, .L__cap_merged_table+32
; CHECK-NEXT:    ldr c20, [c20, :lo12:.L__cap_merged_table+32]
; CHECK-NEXT:    adrp c21, .L__cap_merged_table+48
; CHECK-NEXT:    ldr c21, [c21, :lo12:.L__cap_merged_table+48]
; CHECK-NEXT:    mov x19, xzr
; CHECK-NEXT:  .LBB1_2: // %for.body
; CHECK-NEXT:    // =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    lsl x8, x19, #2
; CHECK-NEXT:    ldr w9, [c20, x8]
; CHECK-NEXT:    add x19, x19, #1 // =1
; CHECK-NEXT:    add w10, w9, #1 // =1
; CHECK-NEXT:    str w9, [c21, x8]
; CHECK-NEXT:    str w10, [c20, x8]
; CHECK-NEXT:    bl g
; CHECK-NEXT:    cmp x19, w0, sxtw
; CHECK-NEXT:    b.lt .LBB1_2
; CHECK-NEXT:  .LBB1_3: // %for.end
; CHECK-NEXT:    ldp c20, c19, [csp, #32] // 32-byte Folded Reload
; CHECK-NEXT:    ldp c30, c21, [csp], #64 // 32-byte Folded Reload
; CHECK-NEXT:    ret c30
entry:
  %call9 = tail call i32 bitcast (i32 (...) addrspace(200)* @g to i32 () addrspace(200)*)()
  %cmp10 = icmp sgt i32 %call9, 0
  br i1 %cmp10, label %for.body, label %for.end

for.body:
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 0, %entry ]
  %arrayidx = getelementptr inbounds [200 x i32], [200 x i32] addrspace(200)* @x1, i64 0, i64 %indvars.iv
  %0 = load i32, i32 addrspace(200)* %arrayidx, align 4
  %inc = add nsw i32 %0, 1
  store i32 %inc, i32 addrspace(200)* %arrayidx, align 4
  %arrayidx2 = getelementptr inbounds [200 x i32], [200 x i32] addrspace(200)* @x2, i64 0, i64 %indvars.iv
  store i32 %0, i32 addrspace(200)* %arrayidx2, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %call = tail call i32 bitcast (i32 (...) addrspace(200)* @g to i32 () addrspace(200)*)()
  %1 = sext i32 %call to i64
  %cmp = icmp slt i64 %indvars.iv.next, %1
  br i1 %cmp, label %for.body, label %for.end

for.end:
  ret void
}

define void @bar(i32 addrspace(200)* %end) local_unnamed_addr addrspace(200) {
; CHECK-LABEL: bar:
; CHECK:       .Lfunc_begin2:
; CHECK-NEXT:    .cfi_startproc purecap
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    stp c30, c19, [csp, #-32]! // 32-byte Folded Spill
; CHECK-NEXT:    .cfi_def_cfa_offset 32
; CHECK-NEXT:    .cfi_offset c19, -16
; CHECK-NEXT:    .cfi_offset c30, -32
; CHECK-NEXT:    mov c19, c0
; CHECK-NEXT:    bl g
; CHECK-NEXT:    cmp w0, #1 // =1
; CHECK-NEXT:    b.lt .LBB2_3
; CHECK-NEXT:  // %bb.1: // %for.body.preheader
; CHECK-NEXT:    adrp c0, .L__cap_merged_table+48
; CHECK-NEXT:    ldr c0, [c0, :lo12:.L__cap_merged_table+48]
; CHECK-NEXT:    adrp c1, .L__cap_merged_table+32
; CHECK-NEXT:    ldr c1, [c1, :lo12:.L__cap_merged_table+32]
; CHECK-NEXT:  .LBB2_2: // %for.body
; CHECK-NEXT:    // =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    ldr w8, [c1], #4
; CHECK-NEXT:    cmp x1, x19
; CHECK-NEXT:    str w8, [c0], #4
; CHECK-NEXT:    b.eq .LBB2_2
; CHECK-NEXT:  .LBB2_3: // %for.end
; CHECK-NEXT:    ldp c30, c19, [csp], #32 // 32-byte Folded Reload
; CHECK-NEXT:    ret c30
entry:
  %call9 = tail call i32 bitcast (i32 (...) addrspace(200)* @g to i32 () addrspace(200)*)()
  %cmp10 = icmp sgt i32 %call9, 0
  br i1 %cmp10, label %for.body, label %for.end

for.body:
  %indvars.iv = phi i32 addrspace(200)* [ %indvars.iv.next, %for.body ], [ getelementptr inbounds ([200 x i32], [200 x i32] addrspace(200)* @x1, i64 0, i64 0), %entry ]
  %indvars.iv2 = phi i32 addrspace(200)* [ %indvars.iv2.next, %for.body ], [ getelementptr inbounds ([200 x i32], [200 x i32] addrspace(200)* @x2, i64 0, i64 0), %entry ]

  %0 = load i32, i32 addrspace(200)* %indvars.iv, align 4
  store i32 %0, i32 addrspace(200)* %indvars.iv2, align 4

  %indvars.iv.next = getelementptr inbounds i32 , i32 addrspace(200)*  %indvars.iv, i32 1
  %indvars.iv2.next = getelementptr inbounds i32, i32 addrspace(200)*  %indvars.iv2, i32 1

  %cmp = icmp eq i32 addrspace(200)* %indvars.iv.next, %end
  br i1 %cmp, label %for.body, label %for.end

for.end:
  ret void
}

; If we only use one global in the function load from the captable directly
; instead of using the merged global.
define i32 addrspace(200)* @baz() local_unnamed_addr addrspace(200) {
; CHECK-LABEL: baz:
; CHECK:       .Lfunc_begin3:
; CHECK-NEXT:    .cfi_startproc purecap
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    adrp c0, .L__cap_merged_table+32
; CHECK-NEXT:    ldr c0, [c0, :lo12:.L__cap_merged_table+32]
; CHECK-NEXT:    ret c30
  ret i32 addrspace(200)* getelementptr inbounds ([200 x i32], [200 x i32] addrspace(200)* @x1, i64 0, i64 0)
}

; Same as above, even if we are doing a safe memory operation.
define void @bif() local_unnamed_addr addrspace(200) {
; CHECK-LABEL: bif:
; CHECK:       .Lfunc_begin4:
; CHECK-NEXT:    .cfi_startproc purecap
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    adrp c0, .L__cap_merged_table+32
; CHECK-NEXT:    ldr c0, [c0, :lo12:.L__cap_merged_table+32]
; CHECK-NEXT:    str wzr, [c0]
; CHECK-NEXT:    ret c30
  store i32 0, i32 addrspace(200)* getelementptr inbounds ([200 x i32], [200 x i32] addrspace(200)* @x1, i64 0, i64 0)
  ret void
}

; Unsafe loads/stores need a bounds setting instruction.
define void @goo() local_unnamed_addr addrspace(200) {
; CHECK-LABEL: goo:
; CHECK:       .Lfunc_begin5:
; CHECK-NEXT:    .cfi_startproc purecap
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    adrp c0, .L__cap_merged_table+32
; CHECK-NEXT:    ldr c0, [c0, :lo12:.L__cap_merged_table+32]
; CHECK-NEXT:    adrp c1, .L__cap_merged_table+48
; CHECK-NEXT:    ldr c1, [c1, :lo12:.L__cap_merged_table+48]
; CHECK-NEXT:    mov w8, #3
; CHECK-NEXT:    str w8, [c0, #804]
; CHECK-NEXT:    str w8, [c1, #804]
; CHECK-NEXT:    ret c30
entry:
  store i32 3, i32 addrspace(200)* getelementptr inbounds ([200 x i32], [200 x i32] addrspace(200)* @x1, i64 1, i64 1), align 4
  store i32 3, i32 addrspace(200)* getelementptr inbounds ([200 x i32], [200 x i32] addrspace(200)* @x2, i64 1, i64 1), align 4
  ret void
}

; If we have one unsafe and one safe the safe one doesn't need a setbounds
define void @bat() local_unnamed_addr addrspace(200) {
; CHECK-LABEL: bat:
; CHECK:       .Lfunc_begin6:
; CHECK-NEXT:    .cfi_startproc purecap
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    adrp c0, .L__cap_merged_table+32
; CHECK-NEXT:    ldr c0, [c0, :lo12:.L__cap_merged_table+32]
; CHECK-NEXT:    adrp c1, .L__cap_merged_table
; CHECK-NEXT:    ldr c1, [c1, :lo12:.L__cap_merged_table]
; CHECK-NEXT:    mov w8, #3
; CHECK-NEXT:    str w8, [c0, #804]
; CHECK-NEXT:    str w8, [c1, #804]
; CHECK-NEXT:    ret c30
entry:
  store i32 3, i32 addrspace(200)* getelementptr inbounds ([200 x i32], [200 x i32] addrspace(200)* @x1, i64 1, i64 1), align 4
  store i32 3, i32 addrspace(200)* getelementptr inbounds ([200 x i32], [200 x i32] addrspace(200)* @x2, i64 0, i64 0), align 4
  ret void
}

; CHECK-LABEL: .L__cap_merged_table:
; CHECK-NEXT:	.chericap .L_MergedGlobals
; CHECK-NEXT:	.chericap x0
; CHECK-NEXT:	.chericap x1
; CHECK-NEXT:	.chericap x2
; CHECK-NEXT:	.size	.L__cap_merged_table, 64

declare i32 @g(...) local_unnamed_addr addrspace(200)
