; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=aarch64-none-elf -mattr=+c64,+morello -target-abi purecap -o - %s | FileCheck %s

; Make sure we don't crash when lowering llvm.smul.with.overflow.* to a library call.

define dso_local i32 @foo(i64 %a, i64 %b) local_unnamed_addr {
; CHECK-LABEL: foo:
; CHECK:       .Lfunc_begin0:
; CHECK-NEXT:    .cfi_startproc purecap
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    sub csp, csp, #32 // =32
; CHECK-NEXT:    str c30, [csp, #16] // 16-byte Folded Spill
; CHECK-NEXT:    .cfi_def_cfa_offset 32
; CHECK-NEXT:    .cfi_offset c30, -16
; CHECK-NEXT:    mov x2, x1
; CHECK-NEXT:    add c4, csp, #8 // =8
; CHECK-NEXT:    mov x1, xzr
; CHECK-NEXT:    mov x3, xzr
; CHECK-NEXT:    str xzr, [csp, #8]
; CHECK-NEXT:    bl __muloti4
; CHECK-NEXT:    ldr c30, [csp, #16] // 16-byte Folded Reload
; CHECK-NEXT:    // kill: def $w0 killed $w0 killed $x0
; CHECK-NEXT:    add csp, csp, #32 // =32
; CHECK-NEXT:    ret c30
entry:
  %aext = zext i64 %a to i65
  %bext = zext i64 %b to i65
  %res = tail call { i65, i1 } @llvm.smul.with.overflow.i65(i65 %aext, i65 %bext)
  %resval = extractvalue { i65, i1 } %res, 0
  %ret = trunc i65 %resval to i32
  ret i32 %ret
}

declare { i65, i1 } @llvm.smul.with.overflow.i65(i65, i65) #0

attributes #0 = { nounwind readnone speculatable willreturn }
