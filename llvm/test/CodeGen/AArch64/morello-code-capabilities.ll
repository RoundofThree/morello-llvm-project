; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=aarch64-none-elf -mattr=+c64,+morello -target-abi=purecap | FileCheck %s -implicit-check-not=.capinit
; RUN: llc < %s -mtriple=aarch64-none-elf -mattr=+c64,+morello -target-abi=purecap -filetype=obj -o - \
; RUN:  | llvm-readobj -r - | FileCheck %s --check-prefix=RELOCS

target triple = "aarch64-none--elf"

define i8 addrspace(200)* @fun1() addrspace(200) nounwind {
; CHECK-LABEL: fun1:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    adrp c0, :got:fun1
; CHECK-NEXT:    ldr c0, [c0, :got_lo12:fun1]
; CHECK-NEXT:    ret c30
entry:
  ret i8 addrspace(200) * bitcast (i8 addrspace(200)* () addrspace(200)* @fun1 to i8 addrspace(200)*)
}

define i8 addrspace(200)* @fun2() addrspace(200) nounwind {
; CHECK-LABEL: fun2:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:  .Ltmp0: // Block address taken
; CHECK-NEXT:  // %bb.1: // %newb
; CHECK-NEXT:    adrp c0, .Ltmp0
; CHECK-NEXT:    add c0, c0, :lo12:.Ltmp0+1
; CHECK-NEXT:    seal c0, c0, rb
; CHECK-NEXT:    ret c30
entry:
  br label %newb
newb:
  ret i8 addrspace(200)* blockaddress(@fun2, %newb)
}

define i64 @blockaddress_in_global() addrspace(200) nounwind {
; CHECK-LABEL: blockaddress_in_global:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    adrp c0, :got:addrof_label_in_global
; CHECK-NEXT:    ldr c0, [c0, :got_lo12:addrof_label_in_global]
; CHECK-NEXT:    ldr c0, [c0, #0]
; CHECK-NEXT:    br c0
; CHECK-NEXT:  .Ltmp1: // Block address taken
; CHECK-NEXT:  .LBB2_1: // %label1
; CHECK-NEXT:    mov w0, #2
; CHECK-NEXT:    ret c30
; CHECK-NEXT:  .Ltmp2: // Block address taken
; CHECK-NEXT:  .LBB2_2: // %label2
; CHECK-NEXT:    mov w0, #3
; CHECK-NEXT:    ret c30
entry:
  %0 = load i8 addrspace(200)*, i8 addrspace(200)* addrspace(200)* @addrof_label_in_global, align 16
  br label %indirectgoto

label1:                                           ; preds = %indirectgoto
  ret i64 2

label2:                                           ; preds = %indirectgoto
  ret i64 3

indirectgoto:                                     ; preds = %entry
  %indirect.goto.dest = phi i8 addrspace(200)* [ %0, %entry ]
  indirectbr i8 addrspace(200)* %indirect.goto.dest, [label %label1, label %label2]
}

; Manual checks from here on:
; UTC_ARGS: --disable
@addrof_label_in_global = addrspace(200) global i8 addrspace(200)* blockaddress(@blockaddress_in_global, %label1), align 16
; CHECK-LABEL: addrof_label_in_global:
; CHECK-NEXT:  .capinit blockaddress_in_global+((.Ltmp1+1)-blockaddress_in_global)
; CHECK-NEXT:  .xword 0
; CHECK-NEXT:  .xword 0
; CHECK-NEXT:  .size addrof_label_in_global, 16
@addrof_label_in_global_2 = addrspace(200) global i8 addrspace(200)* blockaddress(@blockaddress_in_global, %label2), align 16
; CHECK-LABEL: addrof_label_in_global_2:
; CHECK-NEXT:  .capinit blockaddress_in_global+((.Ltmp2+1)-blockaddress_in_global)
; CHECK-NEXT:  .xword 0
; CHECK-NEXT:  .xword 0
; CHECK-NEXT:  .size addrof_label_in_global_2, 16


; All relocations should have an odd addend since they are C64 symbols:
; RELOCS-LABEL: Section ({{.+}}) .rela.data {
; RELOCS-NEXT:    0x0 R_MORELLO_CAPINIT blockaddress_in_global 0x11
; RELOCS-NEXT:    0x10 R_MORELLO_CAPINIT blockaddress_in_global 0x19
; RELOCS-NEXT:  }
