// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
// RUN: %clang_cc1 -ffreestanding -triple aarch64-none-eabi -target-feature +morello -target-feature +c64 -target-abi purecap -target-feature +neon -target-feature +crc -target-feature +crypto -O0 -disable-O0-optnone -fexperimental-new-pass-manager -S -emit-llvm -o - %s | opt -S -mem2reg | FileCheck %s

#include <arm_acle.h>

/* 8 SYNCHRONIZATION, BARRIER AND HINT INTRINSICS */
/* 8.3 Memory Barriers */
// CHECK-LABEL: @test_dmb(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.aarch64.dmb(i32 1)
// CHECK-NEXT:    ret void
//
void test_dmb(void) {
  __dmb(1);
}

// CHECK-LABEL: @test_dsb(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.aarch64.dsb(i32 2)
// CHECK-NEXT:    ret void
//
void test_dsb(void) {
  __dsb(2);
}

// CHECK-LABEL: @test_isb(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.aarch64.isb(i32 3)
// CHECK-NEXT:    ret void
//
void test_isb(void) {
  __isb(3);
}

/* 8.4 Hints */
// CHECK-LABEL: @test_yield(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.aarch64.hint(i32 1) #[[ATTR4:[0-9]+]]
// CHECK-NEXT:    ret void
//
void test_yield(void) {
  __yield();
}

// CHECK-LABEL: @test_wfe(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.aarch64.hint(i32 2) #[[ATTR4]]
// CHECK-NEXT:    ret void
//
void test_wfe(void) {
  __wfe();
}

// CHECK-LABEL: @test_wfi(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.aarch64.hint(i32 3) #[[ATTR4]]
// CHECK-NEXT:    ret void
//
void test_wfi(void) {
  __wfi();
}

// CHECK-LABEL: @test_sev(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.aarch64.hint(i32 4) #[[ATTR4]]
// CHECK-NEXT:    ret void
//
void test_sev(void) {
  __sev();
}

// CHECK-LABEL: @test_sevl(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.aarch64.hint(i32 5) #[[ATTR4]]
// CHECK-NEXT:    ret void
//
void test_sevl(void) {
  __sevl();
}

/* 8.5 Swap */
// CHECK-LABEL: @test_swp(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast i8 addrspace(200)* [[P:%.*]] to i32 addrspace(200)*
// CHECK-NEXT:    br label [[DO_BODY_I:%.*]]
// CHECK:       do.body.i:
// CHECK-NEXT:    [[LDXR_I:%.*]] = call i64 @llvm.aarch64.ldxr.p200i32(i32 addrspace(200)* [[TMP0]]) #[[ATTR4]]
// CHECK-NEXT:    [[TMP1:%.*]] = trunc i64 [[LDXR_I]] to i32
// CHECK-NEXT:    [[TMP2:%.*]] = zext i32 [[X:%.*]] to i64
// CHECK-NEXT:    [[STXR_I:%.*]] = call i32 @llvm.aarch64.stxr.p200i32(i64 [[TMP2]], i32 addrspace(200)* [[TMP0]]) #[[ATTR4]]
// CHECK-NEXT:    [[TOBOOL_I:%.*]] = icmp ne i32 [[STXR_I]], 0
// CHECK-NEXT:    br i1 [[TOBOOL_I]], label [[DO_BODY_I]], label [[__SWP_EXIT:%.*]], !llvm.loop [[LOOP6:![0-9]+]]
// CHECK:       __swp.exit:
// CHECK-NEXT:    ret void
//
void test_swp(uint32_t x, volatile void *p) {
  __swp(x, p);
}

/* 8.6 Memory prefetch intrinsics */
/* 8.6.1 Data prefetch */
// CHECK-LABEL: @test_pld(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.prefetch.p200i8(i8 addrspace(200)* null, i32 0, i32 3, i32 1)
// CHECK-NEXT:    ret void
//
void test_pld() {
  __pld(0);
}

// CHECK-LABEL: @test_pldx(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.prefetch.p200i8(i8 addrspace(200)* null, i32 1, i32 1, i32 1)
// CHECK-NEXT:    ret void
//
void test_pldx() {
  __pldx(1, 2, 0, 0);
}

/* 8.6.2 Instruction prefetch */
// CHECK-LABEL: @test_pli(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.prefetch.p200i8(i8 addrspace(200)* null, i32 0, i32 3, i32 0)
// CHECK-NEXT:    ret void
//
void test_pli() {
  __pli(0);
}

// CHECK-LABEL: @test_plix(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.prefetch.p200i8(i8 addrspace(200)* null, i32 0, i32 1, i32 0)
// CHECK-NEXT:    ret void
//
void test_plix() {
  __plix(2, 0, 0);
}

/* 8.7 NOP */
// CHECK-LABEL: @test_nop(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.aarch64.hint(i32 0) #[[ATTR4]]
// CHECK-NEXT:    ret void
//
void test_nop(void) {
  __nop();
}

/* 9 DATA-PROCESSING INTRINSICS */

/* 9.2 Miscellaneous data-processing intrinsics */
// CHECK-LABEL: @test_ror(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[REM_I:%.*]] = urem i32 [[Y:%.*]], 32
// CHECK-NEXT:    [[CMP_I:%.*]] = icmp eq i32 [[REM_I]], 0
// CHECK-NEXT:    br i1 [[CMP_I]], label [[IF_THEN_I:%.*]], label [[IF_END_I:%.*]]
// CHECK:       if.then.i:
// CHECK-NEXT:    br label [[__ROR_EXIT:%.*]]
// CHECK:       if.end.i:
// CHECK-NEXT:    [[SHR_I:%.*]] = lshr i32 [[X:%.*]], [[REM_I]]
// CHECK-NEXT:    [[SUB_I:%.*]] = sub i32 32, [[REM_I]]
// CHECK-NEXT:    [[SHL_I:%.*]] = shl i32 [[X]], [[SUB_I]]
// CHECK-NEXT:    [[OR_I:%.*]] = or i32 [[SHR_I]], [[SHL_I]]
// CHECK-NEXT:    br label [[__ROR_EXIT]]
// CHECK:       __ror.exit:
// CHECK-NEXT:    [[RETVAL_I_0:%.*]] = phi i32 [ [[X]], [[IF_THEN_I]] ], [ [[OR_I]], [[IF_END_I]] ]
// CHECK-NEXT:    ret i32 [[RETVAL_I_0]]
//
uint32_t test_ror(uint32_t x, uint32_t y) {
  return __ror(x, y);
}

// CHECK-LABEL: @test_rorl(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[REM_I:%.*]] = urem i32 [[Y:%.*]], 64
// CHECK-NEXT:    [[CMP_I:%.*]] = icmp eq i32 [[REM_I]], 0
// CHECK-NEXT:    br i1 [[CMP_I]], label [[IF_THEN_I:%.*]], label [[IF_END_I:%.*]]
// CHECK:       if.then.i:
// CHECK-NEXT:    br label [[__RORLL_EXIT:%.*]]
// CHECK:       if.end.i:
// CHECK-NEXT:    [[SH_PROM_I:%.*]] = zext i32 [[REM_I]] to i64
// CHECK-NEXT:    [[SHR_I:%.*]] = lshr i64 [[X:%.*]], [[SH_PROM_I]]
// CHECK-NEXT:    [[SUB_I:%.*]] = sub i32 64, [[REM_I]]
// CHECK-NEXT:    [[SH_PROM1_I:%.*]] = zext i32 [[SUB_I]] to i64
// CHECK-NEXT:    [[SHL_I:%.*]] = shl i64 [[X]], [[SH_PROM1_I]]
// CHECK-NEXT:    [[OR_I:%.*]] = or i64 [[SHR_I]], [[SHL_I]]
// CHECK-NEXT:    br label [[__RORLL_EXIT]]
// CHECK:       __rorll.exit:
// CHECK-NEXT:    [[RETVAL_I_0:%.*]] = phi i64 [ [[X]], [[IF_THEN_I]] ], [ [[OR_I]], [[IF_END_I]] ]
// CHECK-NEXT:    ret i64 [[RETVAL_I_0]]
//
unsigned long test_rorl(unsigned long x, uint32_t y) {
  return __rorl(x, y);
}

// CHECK-LABEL: @test_rorll(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[REM_I:%.*]] = urem i32 [[Y:%.*]], 64
// CHECK-NEXT:    [[CMP_I:%.*]] = icmp eq i32 [[REM_I]], 0
// CHECK-NEXT:    br i1 [[CMP_I]], label [[IF_THEN_I:%.*]], label [[IF_END_I:%.*]]
// CHECK:       if.then.i:
// CHECK-NEXT:    br label [[__RORLL_EXIT:%.*]]
// CHECK:       if.end.i:
// CHECK-NEXT:    [[SH_PROM_I:%.*]] = zext i32 [[REM_I]] to i64
// CHECK-NEXT:    [[SHR_I:%.*]] = lshr i64 [[X:%.*]], [[SH_PROM_I]]
// CHECK-NEXT:    [[SUB_I:%.*]] = sub i32 64, [[REM_I]]
// CHECK-NEXT:    [[SH_PROM1_I:%.*]] = zext i32 [[SUB_I]] to i64
// CHECK-NEXT:    [[SHL_I:%.*]] = shl i64 [[X]], [[SH_PROM1_I]]
// CHECK-NEXT:    [[OR_I:%.*]] = or i64 [[SHR_I]], [[SHL_I]]
// CHECK-NEXT:    br label [[__RORLL_EXIT]]
// CHECK:       __rorll.exit:
// CHECK-NEXT:    [[RETVAL_I_0:%.*]] = phi i64 [ [[X]], [[IF_THEN_I]] ], [ [[OR_I]], [[IF_END_I]] ]
// CHECK-NEXT:    ret i64 [[RETVAL_I_0]]
//
uint64_t test_rorll(uint64_t x, uint32_t y) {
  return __rorll(x, y);
}

// CHECK-LABEL: @test_clz(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = call i32 @llvm.ctlz.i32(i32 [[T:%.*]], i1 false) #[[ATTR4]]
// CHECK-NEXT:    ret i32 [[TMP0]]
//
uint32_t test_clz(uint32_t t) {
  return __clz(t);
}

// AArch32: call i32 @llvm.ctlz.i32(i32 %t, i1 false)
// CHECK-LABEL: @test_clzl(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = call i64 @llvm.ctlz.i64(i64 [[T:%.*]], i1 false) #[[ATTR4]]
// CHECK-NEXT:    [[CAST_I:%.*]] = trunc i64 [[TMP0]] to i32
// CHECK-NEXT:    [[CONV_I:%.*]] = sext i32 [[CAST_I]] to i64
// CHECK-NEXT:    ret i64 [[CONV_I]]
//
long test_clzl(long t) {
  return __clzl(t);
}

// CHECK-LABEL: @test_clzll(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = call i64 @llvm.ctlz.i64(i64 [[T:%.*]], i1 false) #[[ATTR4]]
// CHECK-NEXT:    [[CAST_I:%.*]] = trunc i64 [[TMP0]] to i32
// CHECK-NEXT:    [[CONV_I:%.*]] = sext i32 [[CAST_I]] to i64
// CHECK-NEXT:    ret i64 [[CONV_I]]
//
uint64_t test_clzll(uint64_t t) {
  return __clzll(t);
}

// CHECK-LABEL: @test_rev(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = call i32 @llvm.bswap.i32(i32 [[T:%.*]]) #[[ATTR4]]
// CHECK-NEXT:    ret i32 [[TMP0]]
//
uint32_t test_rev(uint32_t t) {
  return __rev(t);
}

// AArch32: call i32 @llvm.bswap.i32(i32 %t)
// CHECK-LABEL: @test_revl(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = call i64 @llvm.bswap.i64(i64 [[T:%.*]]) #[[ATTR4]]
// CHECK-NEXT:    ret i64 [[TMP0]]
//
long test_revl(long t) {
  return __revl(t);
}

// CHECK-LABEL: @test_revll(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = call i64 @llvm.bswap.i64(i64 [[T:%.*]]) #[[ATTR4]]
// CHECK-NEXT:    ret i64 [[TMP0]]
//
uint64_t test_revll(uint64_t t) {
  return __revll(t);
}

// CHECK-LABEL: @test_rev16(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = call i32 @llvm.bswap.i32(i32 [[T:%.*]]) #[[ATTR4]]
// CHECK-NEXT:    [[REM_I_I:%.*]] = urem i32 16, 32
// CHECK-NEXT:    [[CMP_I_I:%.*]] = icmp eq i32 [[REM_I_I]], 0
// CHECK-NEXT:    br i1 [[CMP_I_I]], label [[IF_THEN_I_I:%.*]], label [[IF_END_I_I:%.*]]
// CHECK:       if.then.i.i:
// CHECK-NEXT:    br label [[__REV16_EXIT:%.*]]
// CHECK:       if.end.i.i:
// CHECK-NEXT:    [[SHR_I_I:%.*]] = lshr i32 [[TMP0]], [[REM_I_I]]
// CHECK-NEXT:    [[SUB_I_I:%.*]] = sub i32 32, [[REM_I_I]]
// CHECK-NEXT:    [[SHL_I_I:%.*]] = shl i32 [[TMP0]], [[SUB_I_I]]
// CHECK-NEXT:    [[OR_I_I:%.*]] = or i32 [[SHR_I_I]], [[SHL_I_I]]
// CHECK-NEXT:    br label [[__REV16_EXIT]]
// CHECK:       __rev16.exit:
// CHECK-NEXT:    [[RETVAL_I_I_0:%.*]] = phi i32 [ [[TMP0]], [[IF_THEN_I_I]] ], [ [[OR_I_I]], [[IF_END_I_I]] ]
// CHECK-NEXT:    ret i32 [[RETVAL_I_I_0]]
//
uint32_t test_rev16(uint32_t t) {
  return __rev16(t);
}

// CHECK-LABEL: @test_rev16l(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[SHR_I:%.*]] = lshr i64 [[T:%.*]], 32
// CHECK-NEXT:    [[CONV_I:%.*]] = trunc i64 [[SHR_I]] to i32
// CHECK-NEXT:    [[TMP0:%.*]] = call i32 @llvm.bswap.i32(i32 [[CONV_I]]) #[[ATTR4]]
// CHECK-NEXT:    [[REM_I_I10_I:%.*]] = urem i32 16, 32
// CHECK-NEXT:    [[CMP_I_I11_I:%.*]] = icmp eq i32 [[REM_I_I10_I]], 0
// CHECK-NEXT:    br i1 [[CMP_I_I11_I]], label [[IF_THEN_I_I12_I:%.*]], label [[IF_END_I_I17_I:%.*]]
// CHECK:       if.then.i.i12.i:
// CHECK-NEXT:    br label [[__REV16_EXIT18_I:%.*]]
// CHECK:       if.end.i.i17.i:
// CHECK-NEXT:    [[SHR_I_I13_I:%.*]] = lshr i32 [[TMP0]], [[REM_I_I10_I]]
// CHECK-NEXT:    [[SUB_I_I14_I:%.*]] = sub i32 32, [[REM_I_I10_I]]
// CHECK-NEXT:    [[SHL_I_I15_I:%.*]] = shl i32 [[TMP0]], [[SUB_I_I14_I]]
// CHECK-NEXT:    [[OR_I_I16_I:%.*]] = or i32 [[SHR_I_I13_I]], [[SHL_I_I15_I]]
// CHECK-NEXT:    br label [[__REV16_EXIT18_I]]
// CHECK:       __rev16.exit18.i:
// CHECK-NEXT:    [[RETVAL_I_I6_I_0:%.*]] = phi i32 [ [[TMP0]], [[IF_THEN_I_I12_I]] ], [ [[OR_I_I16_I]], [[IF_END_I_I17_I]] ]
// CHECK-NEXT:    [[CONV1_I:%.*]] = zext i32 [[RETVAL_I_I6_I_0]] to i64
// CHECK-NEXT:    [[SHL_I:%.*]] = shl i64 [[CONV1_I]], 32
// CHECK-NEXT:    [[CONV2_I:%.*]] = trunc i64 [[T]] to i32
// CHECK-NEXT:    [[TMP1:%.*]] = call i32 @llvm.bswap.i32(i32 [[CONV2_I]]) #[[ATTR4]]
// CHECK-NEXT:    [[REM_I_I_I:%.*]] = urem i32 16, 32
// CHECK-NEXT:    [[CMP_I_I_I:%.*]] = icmp eq i32 [[REM_I_I_I]], 0
// CHECK-NEXT:    br i1 [[CMP_I_I_I]], label [[IF_THEN_I_I_I:%.*]], label [[IF_END_I_I_I:%.*]]
// CHECK:       if.then.i.i.i:
// CHECK-NEXT:    br label [[__REV16LL_EXIT:%.*]]
// CHECK:       if.end.i.i.i:
// CHECK-NEXT:    [[SHR_I_I_I:%.*]] = lshr i32 [[TMP1]], [[REM_I_I_I]]
// CHECK-NEXT:    [[SUB_I_I_I:%.*]] = sub i32 32, [[REM_I_I_I]]
// CHECK-NEXT:    [[SHL_I_I_I:%.*]] = shl i32 [[TMP1]], [[SUB_I_I_I]]
// CHECK-NEXT:    [[OR_I_I_I:%.*]] = or i32 [[SHR_I_I_I]], [[SHL_I_I_I]]
// CHECK-NEXT:    br label [[__REV16LL_EXIT]]
// CHECK:       __rev16ll.exit:
// CHECK-NEXT:    [[RETVAL_I_I_I_0:%.*]] = phi i32 [ [[TMP1]], [[IF_THEN_I_I_I]] ], [ [[OR_I_I_I]], [[IF_END_I_I_I]] ]
// CHECK-NEXT:    [[CONV4_I:%.*]] = zext i32 [[RETVAL_I_I_I_0]] to i64
// CHECK-NEXT:    [[OR_I:%.*]] = or i64 [[SHL_I]], [[CONV4_I]]
// CHECK-NEXT:    ret i64 [[OR_I]]
//
long test_rev16l(long t) {
  return __rev16l(t);
}

// CHECK-LABEL: @test_rev16ll(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[SHR_I:%.*]] = lshr i64 [[T:%.*]], 32
// CHECK-NEXT:    [[CONV_I:%.*]] = trunc i64 [[SHR_I]] to i32
// CHECK-NEXT:    [[TMP0:%.*]] = call i32 @llvm.bswap.i32(i32 [[CONV_I]]) #[[ATTR4]]
// CHECK-NEXT:    [[REM_I_I10_I:%.*]] = urem i32 16, 32
// CHECK-NEXT:    [[CMP_I_I11_I:%.*]] = icmp eq i32 [[REM_I_I10_I]], 0
// CHECK-NEXT:    br i1 [[CMP_I_I11_I]], label [[IF_THEN_I_I12_I:%.*]], label [[IF_END_I_I17_I:%.*]]
// CHECK:       if.then.i.i12.i:
// CHECK-NEXT:    br label [[__REV16_EXIT18_I:%.*]]
// CHECK:       if.end.i.i17.i:
// CHECK-NEXT:    [[SHR_I_I13_I:%.*]] = lshr i32 [[TMP0]], [[REM_I_I10_I]]
// CHECK-NEXT:    [[SUB_I_I14_I:%.*]] = sub i32 32, [[REM_I_I10_I]]
// CHECK-NEXT:    [[SHL_I_I15_I:%.*]] = shl i32 [[TMP0]], [[SUB_I_I14_I]]
// CHECK-NEXT:    [[OR_I_I16_I:%.*]] = or i32 [[SHR_I_I13_I]], [[SHL_I_I15_I]]
// CHECK-NEXT:    br label [[__REV16_EXIT18_I]]
// CHECK:       __rev16.exit18.i:
// CHECK-NEXT:    [[RETVAL_I_I6_I_0:%.*]] = phi i32 [ [[TMP0]], [[IF_THEN_I_I12_I]] ], [ [[OR_I_I16_I]], [[IF_END_I_I17_I]] ]
// CHECK-NEXT:    [[CONV1_I:%.*]] = zext i32 [[RETVAL_I_I6_I_0]] to i64
// CHECK-NEXT:    [[SHL_I:%.*]] = shl i64 [[CONV1_I]], 32
// CHECK-NEXT:    [[CONV2_I:%.*]] = trunc i64 [[T]] to i32
// CHECK-NEXT:    [[TMP1:%.*]] = call i32 @llvm.bswap.i32(i32 [[CONV2_I]]) #[[ATTR4]]
// CHECK-NEXT:    [[REM_I_I_I:%.*]] = urem i32 16, 32
// CHECK-NEXT:    [[CMP_I_I_I:%.*]] = icmp eq i32 [[REM_I_I_I]], 0
// CHECK-NEXT:    br i1 [[CMP_I_I_I]], label [[IF_THEN_I_I_I:%.*]], label [[IF_END_I_I_I:%.*]]
// CHECK:       if.then.i.i.i:
// CHECK-NEXT:    br label [[__REV16LL_EXIT:%.*]]
// CHECK:       if.end.i.i.i:
// CHECK-NEXT:    [[SHR_I_I_I:%.*]] = lshr i32 [[TMP1]], [[REM_I_I_I]]
// CHECK-NEXT:    [[SUB_I_I_I:%.*]] = sub i32 32, [[REM_I_I_I]]
// CHECK-NEXT:    [[SHL_I_I_I:%.*]] = shl i32 [[TMP1]], [[SUB_I_I_I]]
// CHECK-NEXT:    [[OR_I_I_I:%.*]] = or i32 [[SHR_I_I_I]], [[SHL_I_I_I]]
// CHECK-NEXT:    br label [[__REV16LL_EXIT]]
// CHECK:       __rev16ll.exit:
// CHECK-NEXT:    [[RETVAL_I_I_I_0:%.*]] = phi i32 [ [[TMP1]], [[IF_THEN_I_I_I]] ], [ [[OR_I_I_I]], [[IF_END_I_I_I]] ]
// CHECK-NEXT:    [[CONV4_I:%.*]] = zext i32 [[RETVAL_I_I_I_0]] to i64
// CHECK-NEXT:    [[OR_I:%.*]] = or i64 [[SHL_I]], [[CONV4_I]]
// CHECK-NEXT:    ret i64 [[OR_I]]
//
uint64_t test_rev16ll(uint64_t t) {
  return __rev16ll(t);
}

// CHECK-LABEL: @test_revsh(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = call i16 @llvm.bswap.i16(i16 [[T:%.*]]) #[[ATTR4]]
// CHECK-NEXT:    ret i16 [[TMP0]]
//
int16_t test_revsh(int16_t t) {
  return __revsh(t);
}

// CHECK-LABEL: @test_rbit(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[RBIT_I:%.*]] = call i32 @llvm.bitreverse.i32(i32 [[T:%.*]]) #[[ATTR4]]
// CHECK-NEXT:    ret i32 [[RBIT_I]]
//
uint32_t test_rbit(uint32_t t) {
  return __rbit(t);
}

// CHECK-LABEL: @test_rbitl(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[RBIT_I:%.*]] = call i64 @llvm.bitreverse.i64(i64 [[T:%.*]]) #[[ATTR4]]
// CHECK-NEXT:    ret i64 [[RBIT_I]]
//
long test_rbitl(long t) {
  return __rbitl(t);
}

// CHECK-LABEL: @test_rbitll(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[RBIT_I:%.*]] = call i64 @llvm.bitreverse.i64(i64 [[T:%.*]]) #[[ATTR4]]
// CHECK-NEXT:    ret i64 [[RBIT_I]]
//
uint64_t test_rbitll(uint64_t t) {
  return __rbitll(t);
}

/* 9.7 CRC32 intrinsics */
// CHECK-LABEL: @test_crc32b(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = zext i8 [[B:%.*]] to i32
// CHECK-NEXT:    [[TMP1:%.*]] = call i32 @llvm.aarch64.crc32b(i32 [[A:%.*]], i32 [[TMP0]]) #[[ATTR4]]
// CHECK-NEXT:    ret i32 [[TMP1]]
//
uint32_t test_crc32b(uint32_t a, uint8_t b) {
  return __crc32b(a, b);
}

// CHECK-LABEL: @test_crc32h(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = zext i16 [[B:%.*]] to i32
// CHECK-NEXT:    [[TMP1:%.*]] = call i32 @llvm.aarch64.crc32h(i32 [[A:%.*]], i32 [[TMP0]]) #[[ATTR4]]
// CHECK-NEXT:    ret i32 [[TMP1]]
//
uint32_t test_crc32h(uint32_t a, uint16_t b) {
  return __crc32h(a, b);
}

// CHECK-LABEL: @test_crc32w(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = call i32 @llvm.aarch64.crc32w(i32 [[A:%.*]], i32 [[B:%.*]]) #[[ATTR4]]
// CHECK-NEXT:    ret i32 [[TMP0]]
//
uint32_t test_crc32w(uint32_t a, uint32_t b) {
  return __crc32w(a, b);
}

// CHECK-LABEL: @test_crc32d(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = call i32 @llvm.aarch64.crc32x(i32 [[A:%.*]], i64 [[B:%.*]]) #[[ATTR4]]
// CHECK-NEXT:    ret i32 [[TMP0]]
//
uint32_t test_crc32d(uint32_t a, uint64_t b) {
  return __crc32d(a, b);
}

// CHECK-LABEL: @test_crc32cb(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = zext i8 [[B:%.*]] to i32
// CHECK-NEXT:    [[TMP1:%.*]] = call i32 @llvm.aarch64.crc32cb(i32 [[A:%.*]], i32 [[TMP0]]) #[[ATTR4]]
// CHECK-NEXT:    ret i32 [[TMP1]]
//
uint32_t test_crc32cb(uint32_t a, uint8_t b) {
  return __crc32cb(a, b);
}

// CHECK-LABEL: @test_crc32ch(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = zext i16 [[B:%.*]] to i32
// CHECK-NEXT:    [[TMP1:%.*]] = call i32 @llvm.aarch64.crc32ch(i32 [[A:%.*]], i32 [[TMP0]]) #[[ATTR4]]
// CHECK-NEXT:    ret i32 [[TMP1]]
//
uint32_t test_crc32ch(uint32_t a, uint16_t b) {
  return __crc32ch(a, b);
}

// CHECK-LABEL: @test_crc32cw(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = call i32 @llvm.aarch64.crc32cw(i32 [[A:%.*]], i32 [[B:%.*]]) #[[ATTR4]]
// CHECK-NEXT:    ret i32 [[TMP0]]
//
uint32_t test_crc32cw(uint32_t a, uint32_t b) {
  return __crc32cw(a, b);
}

// CHECK-LABEL: @test_crc32cd(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = call i32 @llvm.aarch64.crc32cx(i32 [[A:%.*]], i64 [[B:%.*]]) #[[ATTR4]]
// CHECK-NEXT:    ret i32 [[TMP0]]
//
uint32_t test_crc32cd(uint32_t a, uint64_t b) {
  return __crc32cd(a, b);
}

/* 10.1 Special register intrinsics */
// CHECK-LABEL: @test_rsr(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = call i64 @llvm.read_volatile_register.i64(metadata [[META8:![0-9]+]])
// CHECK-NEXT:    [[TMP1:%.*]] = trunc i64 [[TMP0]] to i32
// CHECK-NEXT:    ret i32 [[TMP1]]
//
uint32_t test_rsr() {
  return __arm_rsr("1:2:3:4:5");
}

// CHECK-LABEL: @test_rsr64(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = call i64 @llvm.read_volatile_register.i64(metadata [[META8]])
// CHECK-NEXT:    ret i64 [[TMP0]]
//
uint64_t test_rsr64() {
  return __arm_rsr64("1:2:3:4:5");
}

// CHECK-LABEL: @test_rsrp(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = call i64 @llvm.read_volatile_register.i64(metadata [[META9:![0-9]+]])
// CHECK-NEXT:    [[TMP1:%.*]] = inttoptr i64 [[TMP0]] to i8 addrspace(200)*
// CHECK-NEXT:    ret i8 addrspace(200)* [[TMP1]]
//
void *test_rsrp() {
  return __arm_rsrp("sysreg");
}

// CHECK-LABEL: @test_wsr(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = zext i32 [[V:%.*]] to i64
// CHECK-NEXT:    call void @llvm.write_register.i64(metadata [[META8]], i64 [[TMP0]])
// CHECK-NEXT:    ret void
//
void test_wsr(uint32_t v) {
  __arm_wsr("1:2:3:4:5", v);
}

// CHECK-LABEL: @test_wsr64(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.write_register.i64(metadata [[META8]], i64 [[V:%.*]])
// CHECK-NEXT:    ret void
//
void test_wsr64(uint64_t v) {
  __arm_wsr64("1:2:3:4:5", v);
}

// CHECK-LABEL: @test_wsrp(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint i8 addrspace(200)* [[V:%.*]] to i64
// CHECK-NEXT:    call void @llvm.write_register.i64(metadata [[META9]], i64 [[TMP0]])
// CHECK-NEXT:    ret void
//
void test_wsrp(void *v) {
  __arm_wsrp("sysreg", v);
}

